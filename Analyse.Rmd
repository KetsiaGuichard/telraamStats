---
title: "Analyse de Corrélation"
author: "Kevin"
date: system date()
output:
  rmdformats::downcute:
    logo: logo.jpg
    favicon: logo.jpg
    downcute_theme: chaos
    highlight: tango
    number_sections: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```




```{r, message=FALSE, include=FALSE,warning=FALSE, "Import autre fichiers"}
source("fonction_meteo.R")
source("Import_Data.R")
source("fonction_filtre_data.R")

```



```{r, message=FALSE, include=FALSE ,echo=FALSE, "Import packages"}
library(telraamStats)
library(ggplot2)
library(tidyverse)
library(patchwork)
library(prophet)
library(corrplot)

#devtools::install_github("https://github.com/KetsiaGuichard/telraamStats",
 #                        dependencies = TRUE,
  #                       build_vignettes = TRUE)
```




```{r, include=FALSE, "Ajout du type de NA"}
# Ajout de la colonne du type de données manquantes

liste_data_capteurs = list(data_01, data_02, data_04, data_05,data_06, data_07, data_08,data_10, data_11, data_13, data_14, data_15, data_16, data_18)


for(i in 1:length(liste_data_capteurs)) {
  liste_data_capteurs[[i]] = NA_Type(liste_data_capteurs[[i]])
}

visu_na(new_data(meteo, liste_data_capteurs[[1]]))
visu_na(meteo)
visu_na(liste_data_capteurs[[1]] %>% filter(type == 2)
)
```





```{r message=FALSE, warning=FALSE, include=FALSE, "Corrélation cahque capteurs"}
## Analyse de corrélation des variables météo avec chaque capteur indépendemment.

#On fait le choix de ne rien enlever comme données pour cette première analyse afin de voir l'impact après #suppression de certaines données (les heures de nuit). 



#Création de liste de données capteur + météo

liste_data_capteurs_meteo <- list()

for(i in 1:length(liste_data_capteurs)){
  liste_data_capteurs_meteo[[i]] = new_data(meteo, liste_data_capteurs[[i]])
}


# Matrice de corrélation pour chaque variable

for(i in 1:length(liste_data_capteurs_meteo)){
 corrélation_uptime(liste_data_capteurs_meteo[[i]], liste_var_selected = c("T", "U", "VV", "RR1", "GLO", "pedestrian", "vehicule"))
}

```



# Analyse de corrélation sur les variables météo et l'ensemble des capteurs

+ avec filtre des données manquantes de type 2 (faisant varier le seuil definissant le type 2 de 25 à 50 pas de 5) mais sans suppression de données de la nuit

L'objectif étant de constater la nuances du résultat des corrélations avant et après suppression

```{r, echo=FALSE}
for(i in seq(25, 50, 5)) {
  corrélation_uptime(
    new_data(meteo, (NA_Type(
      sensors, threshold = i
    ))) %>% filter(type == 2),
    liste_var_selected = c("T", "U", "VV", "GLO", "pedestrian", "vehicule")
  )
}
```

On remarque que plus on augmente le seuil plus les corrélation diminue mais faiblement

------------------

+ avec un filtre sur les valeurs manquantes de type 2 (faisant varier le seuil nous permettant de définir les valeurs manquantes de type 2 de 25 à 50 avec un pas de 5) et suppression des heures de nuit


```{r, message=FALSE, warning=FALSE, echo=FALSE}

for(i in seq(25, 50, 5)){
  corrélation_uptime(new_data(meteo, stop_sensor(NA_Type(sensors, threshold = i), remove_data = TRUE, uptime_choice = 0.5)) %>% filter(type==2), liste_var_selected = c("T", "U", "VV", "GLO", "pedestrian", "vehicule"))
}

```

La remarque reste la même que précédemment: plus on augmente le seuil plus les corrélation diminue mais faiblement



# Analyse de corrélation de l'ensemble des capteurs sans filtre de données manquantes de type 2 mais avec suppression des heures de nuit


```{r, message=FALSE, warning=FALSE, echo=FALSE}
corrélation_uptime(
  new_data(meteo, stop_sensor(NA_Type(sensors))),
  liste_var_selected = c("T", "U", "VV", "RR1", "GLO", "pedestrian", "vehicule")
)
```


On remarque que les corrélation sont plus faibles que les précédentes (avec un seuil de 50%) ce qui confirme le fait que les données manquantes de type 2 sont plus corrélées avec les variables météo



# Analyse de corrélation de l'ensemble des capteurs avec un filtre sur les valeurs manquantes de type 2 sans suppression des heures de nuit.


```{r, echo=FALSE}
corrélation_uptime(new_data(meteo, NA_Type(sensors)) %>% filter(type==2), liste_var_selected = c("T", "U", "VV", "RR1", "GLO", "pedestrian", "vehicule"))

```


Malgré le fait que l'on conserve les heures de nuit, les corrélations sont toutes autant importantes.

------------------

# Corrélation à partir d'une ACP sur les données nettoyées sans filtre de NA de type 2

```{r, message=FALSE, warning=FALSE, echo=FALSE}
ACP1 = FactoMineR::PCA(new_data(meteo, stop_sensor(NA_Type(sensors))) %>% select(uptime, U, T, GLO, VV, RR1), scale.unit = TRUE, graph = FALSE)

# plot ACP des variables
FactoMineR::plot.PCA(ACP1, axes=c(1,2), choix="var")
```

---------------

# Corrélation à partir d'une ACP après nettoyage et filtre

```{r, message=FALSE, warning=FALSE, echo=FALSE}
ACP2 = FactoMineR::PCA(new_data(meteo, stop_sensor(NA_Type(sensors))) %>% filter(type==2) %>% select(uptime, U, T, GLO, VV, RR1), scale.unit = TRUE, graph = FALSE)

# plot ACP des variables
FactoMineR::plot.PCA(ACP2, axes=c(1,2), choix="var")
```




# Nettoyage de données

```{r}
# Récupération des données nettoyées avec les paramètres par defaut de Clean_NA_segments
sensors_cleaned = Clean_NA_segments(sensors)

# Récupération des données nettoyées et ajout des NA aux vehicules
sensors_cleaned_na = sensors_cleaned %>% mutate(vehicule = ifelse(uptime < 0.5, NA, car+heavy), operation = ifelse(uptime_quality, "original","imputed"))
```



# Imputation par EMA (Exponential Moving Average)

```{r}
# Test sur le capteur 11 (Rue de Prieure: V2)

# Récupérons les données excepté en 2024 (jeu d'entrainement)
train_data11 = sensors_cleaned_na %>% filter(year(date) < 2024 & segment_name == "Burel-01")

# Récupérons les données de janvier 2024 (jeu de test)
test_data11 = sensors_cleaned_na %>% filter(year(date) == 2024 & month(date) == 1 & segment_name == "Burel-01")

# Imputation par EMA sur le jeu de données d'entrainement

# Imputation des valeurs manquantes par interpolation cubique (spline)
train_data11$vehicule_Imputed = zoo::na.spline((train_data11$vehicule), na.rm = FALSE)



# Combler les valeurs manquantes en début et fin de série // ceci ce fait dans le cas où des données manquates se trouves en début ou fin de série
#train_data11$vehicule <- zoo::na.fill(train_data11$vehicule, "extend")

# Impuation par EMA
ema = TTR::EMA(train_data11$vehicule_Imputed, n=3)
ema = data.frame(date = train_data11$date, predic_ema = ema,  predic_spline= train_data11$vehicule_Imputed, type = train_data11$operation)


ema

# Remplacons les valeurs de type "original" de la colonne "predic_spline" dans la zone correspondante de "predic_ema"
ema$predic_ema = ifelse(ema$type == "original", ema$predic_spline, ema$predic_ema)

ggplot() +
  geom_point(data = ema, aes(x = date, y = predic_ema, color = type)) +
  geom_point(data= ema %>% filter(type=="imputed"), aes(x = date, y = predic_spline), color="green") +
  labs(title = "EMA with Imputed Values",
       x = "Date",
       y = "Value",
       color = "Data Type")

```


```{r}
# data frame avec toutes les données de 2024 de RuePrieure-11
Train_data = na.omit(train_data11)

# créons une nouvelle colonne (test) en intoduisant 20% de NA
Train_data$test = Train_data$vehicule
Train_data$test[sample(1:nrow(Train_data), nrow(Train_data)*0.2)] = NA
Train_data = Train_data %>% mutate(operation = ifelse(is.na(test), "imputed","original"))

# Imputation par EMA sur le jeu de données d'entrainement

# Imputation des valeurs manquantes par interpolation cubique (spline)
Train_data$vehicule_Imputed = zoo::na.spline((Train_data$test), na.rm = FALSE)



# Combler les valeurs manquantes en début et fin de série // ceci ce fait dans le cas où des données manquates se trouves en début ou fin de série
#train_data11$vehicule <- zoo::na.fill(train_data11$vehicule, "extend")

# Impuation par EMA
ema_test = TTR::EMA(Train_data$vehicule_Imputed, n=3)
ema_test = data.frame(date = Train_data$date, predic_ema = ema_test,  predic_spline= Train_data$vehicule_Imputed, type = Train_data$operation, original = Train_data$vehicule)




# Remplacons les valeurs de type "original" de la colonne "predic_spline" dans la zone correspondante de "predic_ema"
ema_test$predic_ema = ifelse(ema_test$type == "original", ema_test$predic_spline, ema_test$predic_ema)

ema_test %>% filter(type=="imputed")
```

```{r}
plot(ema_test$original, type = 'l', col = 'blue', ylim = range(c(ema_test$vehicule, ema_test$predic_ema)), main = "Real vs Predicted (EMA)", xlab = "Time", ylab = "Values")
lines(ema_test$predic_ema, col = 'red')
legend("topright", legend = c("Real", "Predicted"), col = c("blue", "red"), lty = 1)

```

```{r}
plot(ema_test$original, col = "blue",type="l", ylim = range(c(ema_test$vehicule, ema_test$predic_spline)), main = "Real vs Predicted (Spline interpolation)", xlab = "Time", ylab = "Values")
lines(ema_test$predic_spline, col = "red")
legend("topright", legend = c("Real", "Predicted"), col = c("blue", "red"), lty = 1)
```



```{r}
plot(ema_test$original, col = as.factor(ema_test$type), ylim = range(c(ema_test$vehicule, ema_test$predic_spline)), main = "Real vs Predicted (Spline interpolation)", xlab = "Time", ylab = "Values")
lines(ema_test$predic_spline, col = as.factor(ema_test$type))
#legend("topright", legend = c("Real", "Predicted"), col = c("blue", "red"), lty = 1)
```






# Fonction de visu de prédiction EMA et spline sur des données avant 2024

```{r}

# En vert c'est la prédiction par interpolation de spline

visu_predict = function(nom_capteur) {
  # Récupérons les données excepté en 2024 (jeu d'entrainement)
  train_data = sensors_cleaned_na %>% filter(year(date) < 2024 &
                                               segment_name == nom_capteur)
  
  # Imputation par EMA sur le jeu de données d'entrainement
  
  # Imputation des valeurs manquantes par interpolation cubique (spline)
  train_data$vehicule_Imputed = zoo::na.spline((train_data$vehicule), na.rm = FALSE)
  
  
  
  # Combler les valeurs manquantes en début et fin de série // ceci ce fait dans le cas où des données manquates se trouves en début ou fin de série
  #train_data11$vehicule <- zoo::na.fill(train_data11$vehicule, "extend")
  
  # Impuation par EMA
  ema = TTR::EMA(train_data$vehicule_Imputed, n = 3)
  ema = data.frame(
    date = train_data$date,
    predic_ema = ema,
    predic_spline = train_data$vehicule_Imputed,
    type = train_data$operation
  )
  
  
  p <- ggplot() +
    geom_point(data = ema, aes(x = date, y = predic_ema, color = type)) +
    geom_point(
      data = ema %>% filter(type == "imputed"),
      aes(x = date, y = predic_spline),
      color = "green"
    ) +
    labs(
      title = "EMA with Imputed Values",
      x = "Date",
      y = "Value",
      color = "Data Type"
    )
  return(p)
}

visu_predict("BoulevardLiberté-18")
```


# Meilleure présentation de l'analyse du fonctionnement des capteurs en fonction de la météo:


```{r, include=FALSE, "Ajout du type de NA"}
# Ajout de la colonne du type de données manquantes

liste_data_capteurs = list(data_01, data_02, data_04, data_05,data_06, data_07, data_08,data_10, data_11, data_13, data_14, data_15, data_16, data_18)

sensors_type = NA_Type(sensors, threshold = 50)

# Créer une liste de données capteurs avec ajout de la colonne type de NA à partir d'un filtre sur sensors

for(i in 1:length(liste_data_capteurs)){
    liste_data_capteurs[[i]] =sensors_type %>% filter(segment_name==liste_data_capteurs[[i]]$segment_name[[1]])
}


visu_na(new_data(meteo, liste_data_capteurs[[1]]))
visu_na(meteo)
visu_na(liste_data_capteurs[[1]] %>% filter(type==2))
```





```{r message=FALSE, warning=FALSE, include=FALSE, "Corrélation chaque capteurs"}
## Analyse de corrélation des variables météo avec chaque capteur indépendemment.

#On fait le choix de ne rien enlever comme données pour cette première analyse afin de voir l'impact après #suppression de certaines données (les heures de nuit). 



#Création de liste de données capteur + météo

liste_data_capteurs_meteo <- list()

for(i in 1:length(liste_data_capteurs)){
  liste_data_capteurs_meteo[[i]] = new_data(meteo, liste_data_capteurs[[i]])
}
```



```{r, echo=FALSE}
# Matrice de corrélation pour chaque variable

for(i in 1:length(liste_data_capteurs_meteo)){
 corrélation_uptime(liste_data_capteurs_meteo[[i]], liste_var_selected = c("T", "U", "VV", "RR1", "GLO", "pedestrian", "vehicule"))
}

```



# Analyse de corrélation sur les variables météo et l'ensemble des capteurs

+ avec filtre des données manquantes de type 2 (faisant varier le seuil definissant le type 2 de 25 à 50 pas de 5) mais sans suppression de données de la nuit

L'objectif étant de constater la nuances du résultat des corrélations avant et après suppression

```{r, echo=FALSE}
for(i in seq(25, 50, 5)){
  corrélation_uptime(new_data(meteo, (NA_Type(sensors, threshold = i))) %>% filter(type==2), liste_var_selected = c("T", "U", "VV", "GLO", "pedestrian", "vehicule"))
}
```

On remarque que plus on augmente le seuil plus les corrélation diminue mais faiblement

------------------

+ avec un filtre sur les valeurs manquantes de type 2 (faisant varier le seuil nous permettant de définir les valeurs manquantes de type 2 de 25 à 50 avec un pas de 5) et suppression des heures de nuit


```{r, message=FALSE, warning=FALSE, echo=FALSE}

for(i in seq(25, 50, 5)){
  corrélation_uptime(new_data(meteo, stop_sensor(NA_Type(sensors, threshold = i), remove_data = TRUE, uptime_choice = 0.5)) %>% filter(type==2), liste_var_selected = c("T", "U", "VV", "GLO", "pedestrian", "vehicule"))
}

```

La remarque reste la même que précédemment: plus on augmente le seuil plus les corrélation diminue mais faiblement



# Analyse de corrélation de l'ensemble des capteurs sans filtre de données manquantes de type 2 mais avec suppression des heures de nuit


```{r, message=FALSE, warning=FALSE, echo=FALSE}
corrélation_uptime(new_data(meteo, stop_sensor(NA_Type(sensors))), liste_var_selected = c("T", "U", "VV", "RR1", "GLO", "pedestrian", "vehicule"))
```


On remarque que les corrélation sont plus faibles que les précédentes (avec un seuil de 50%) ce qui confirme le fait que les données manquantes de type 2 sont plus corrélées avec les variables météo



# Analyse de corrélation de l'ensemble des capteurs avec un filtre sur les valeurs manquantes de type 2 sans suppression des heures de nuit.


```{r, echo=FALSE}
corrélation_uptime(new_data(meteo, NA_Type(sensors)) %>% filter(type==2), liste_var_selected = c("T", "U", "VV", "RR1", "GLO", "pedestrian", "vehicule"))

```


Malgré le fait que l'on conserve les heures de nuit, les corrélations sont toutes autant importantes.


---------------

# Même travail en utilisant mes fonctions pour le calcul de corrélation

# Analyse des corrélation du fonctionnement des capteurs avec les variables météo

```{r}
# Analyse de corrélation des variables météo avec chaque capteur indépendemment avec suppression des heures de nuit
for(i in seq_along(liste_data_capteurs)){
 plot(corrélation_uptime(new_data(meteo, stop_sensor(liste_data_capteurs[[i]])) , liste_var_meteo = c("T", "U", "VV", "GLO"))[[2]])
}

```

De façon générale: corrélation ]0,0.3[

1. Faible relation linéaire positive :

   + Il existe une légère tendance pour laquelle, lorsque le rayonnement global horaire augmente, le fonctionnement du capteur augmente également. Cependant, cette relation est très faible.
   + La faible valeur de la corrélation signifie que d'autres facteurs pourraient influencer fortement le fonctionnement du capteur, ou que la relation entre le rayonnement global et le fonctionnement du capteur n'est pas principalement linéaire.

Implication pratique :

  +  Le fonctionnement du capteur n'est pas fortement dépendant du rayonnement global horaire. Même en l'absence de périodes nocturnes, d'autres variables non considérées dans l'analyse peuvent jouer un rôle significatif.
  +  Si l'objectif est de modéliser ou de prédire le fonctionnement du capteur basé uniquement sur le rayonnement global, une faible corrélation indique que ce modèle serait peu précis.

Autres analyses possibles :

  +  Considérer d'autres facteurs ou variables qui pourraient affecter le fonctionnement du capteur pour obtenir une image plus complète.
  +  Examiner si une transformation des données (logarithmique, quadratique, etc.) ou une autre méthode de corrélation (comme Spearman) révèle des relations non linéaires plus significatives.


```{r, message=FALSE}
# Ajouter la ligne qui présente la tendance global de l'évolution

ggplot(new_data(meteo, stop_sensor(liste_data_capteurs[[1]])),
       aes(x = GLO, y = uptime, color = GLO > 54)) +
  geom_point() +
  geom_smooth(method = "loess", col = "yellow") +
  labs(
    title = "Relation entre le rayonnement global et le fonctionnement du capteur",
    x = "Rayonnement global horaire",
    y = "Fonctionnement du capteur",
    subtitle = unique(new_data(
      meteo, stop_sensor(liste_data_capteurs[[1]])
    )["segment_name"][[1]])
  ) + guides(colour = "none")

#new_data(meteo, stop_sensor(liste_data_capteurs[[1]]))["segment_name"][[1]]

ggplot(new_data(meteo, stop_sensor(liste_data_capteurs[[2]])),
       aes(
         x = GLO,
         y = uptime,
         color = GLO > 46 & GLO < 200
       )) +
  geom_point() +
  geom_smooth(method = "loess", col = "yellow") +
  labs(
    title = "Relation entre le rayonnement global et le fonctionnement du capteur",
    x = "Rayonnement global horaire",
    y = "Fonctionnement du capteur",
    subtitle = unique(new_data(
      meteo, stop_sensor(liste_data_capteurs[[2]])
    )["segment_name"][[1]])
  ) + guides(colour = "none")


ggplot(new_data(meteo, stop_sensor(liste_data_capteurs[[3]])),
       aes(x = GLO, y = uptime, color = GLO > 56)) +
  geom_point() +
  geom_smooth(method = "loess", col = "yellow") +
  labs(
    title = "Relation entre le rayonnement global et le fonctionnement du capteur",
    x = "Rayonnement global horaire",
    y = "Fonctionnement du capteur",
    subtitle = unique(new_data(
      meteo, stop_sensor(liste_data_capteurs[[3]])
    )["segment_name"][[1]])
  ) + guides(colour = "none")
```


Ces graphes nous présente les tendances générales de l'évolution du fonctionnement des capteurs en fonction d'une des variables météo (ici le rayonnement global horaire).

"La méthode **LOESS** est une technique de lissage non paramétrique utilisée pour estimer une relation entre 2 variables dans une regression non linéaire. Elle est basée sur une régression locale qui consiste à ajuster un modèle de régression linéaire à un sous-ensemble des données. Cela permet de capturer les tendances locales dans les données qui ne seraient pas capturées par une régression linéaire globale.

Ainsi, elle peut s'adapter à des formes de relations complexes et non linéaires sans avoir à spécifier une forme fonctionnelle précise"

Comme interpreté précédemment par les valeurs de corrélation, il existe une légère tendance pour laquelle, lorsque le rayonnement global horaire augmente, le fonctionnement du capteur augmente également. Cependant, cette relation est très faible.


```{r}
# Diagramme en barre pour visualiser l'évolution des corrélations de l'uptime en fonction de GLO
ggplot(new_data(meteo, stop_sensor(liste_data_capteurs[[1]])), aes(x = GLO, y = uptime, fill = uptime > 0.5)) +
  geom_bar(stat = "identity") +
  labs(title = "Relation entre uptime et GLO",
       x = "GLO",
       y = "uptime", subtitle =unique(new_data(meteo, stop_sensor(liste_data_capteurs[[1]]))["segment_name"][[1]]) ) +
  theme_minimal()

ggplot(new_data(meteo, stop_sensor(liste_data_capteurs[[2]])), aes(x = GLO, y = uptime, color=GLO>46 & GLO<200)) +
  geom_point() +
  geom_smooth(method = "lm", col="yellow") +
  labs(title = "Relation entre le rayonnement global et le fonctionnement du capteur",
       x = "Rayonnement global horaire",
       y = "Fonctionnement du capteur", subtitle =unique(new_data(meteo, stop_sensor(liste_data_capteurs[[2]]))["segment_name"][[1]]) ) + guides(colour="none")

```



```{r}
# Matrice de corrélation pour chaque capteur sans filtre de la nuit

for(i in seq_along(liste_data_capteurs_meteo)){
 plot(corrélation_uptime(liste_data_capteurs_meteo[[i]])[[2]])
}
```

On remarque une augmentation significative des valeurs de corrélation de GLO et uptime. Cela est dû au fait que ces deux variables on un fonctionnement similaire durant les périodes de nuits (valeurs proches ou égales à 0). Pour une étude de la relation entre le fonctionnement de capteur et les variables météo, il est préférable de supprimer ces périodes de nuit(car elles ont une variabilité très faible et ainsi biaise notre analyse).



Dans la suite de notre analyse, nous allons supprimer ces périodes de nuit pour voir l'impact sur les corrélations.


```{r}
# Matrice de corrélation pour chaque capteur avec filtre sur les NA de type 2

for(i in seq_along(liste_data_capteurs)){
 plot(corrélation_uptime(new_data(meteo, stop_sensor(liste_data_capteurs[[i]])) %>% filter(type==2))[[2]])
}

```


Notes: Les coefficents de corrélation pour les données manquantes de type 2 (données  dont l'uptime < 0.5 de facon multiple: 50% des capteurs) sont modérées et positives pour le GLO et l'uptime. NA de type 2 => qu'il s'agit des données de capteurs dont l'uptime < 0.5. On peut de ce fait interpreté ces coeffis=cients de la façon suivante: 

Pour ces données, généralement quand le rayonnement horaire augmente, la qualité du fonctionnement des capteurs tend aussi à augmenter. Etant plus ou moins significatives comme valeurs, on est tenté de penser que ces valeurs sont généralement observées pour les données en fin de journées et/ou en début de matinée.

Les capteurs de type V2 ayant de meilleures performances pour certaines heures de soirées et de début de journée, les valeurs des coefficients de corrélation baissent généralement sur ces capteurs là et sont plus significatif sur les V1


Suggestion possible: installer des éclairages à proximité des capteurs qui fonctionneront en fin de journée et en début de matinée.


```{r}
ggplot(new_data(meteo, stop_sensor(liste_data_capteurs[[1]])) %>% filter(type==2), aes(x = GLO, y = uptime)) +
  geom_point(col="blue") +
  geom_smooth(method = "loess", col="yellow") +
  labs(title = "Relation entre le rayonnement global et le mauvais fonctionnement du capteur",
       x = "Rayonnement global horaire",
       y = "Fonctionnement du capteur", subtitle =unique(new_data(meteo, stop_sensor(liste_data_capteurs[[1]]))["segment_name"][[1]]) ) + guides(colour="none")
```



```{r}

for(i in seq_along(liste_data_capteurs)){
 plot(corrélation_uptime(new_data(meteo, stop_sensor(liste_data_capteurs[[i]])) %>% filter(uptime_quality==TRUE))[[2]])
}
```

Interpretation: Il existe une tendance sur les données des capteurs avec un uptime > 0.5: en effet, pour les valeurs traduisant le bon fonctionnement des capteurs, on se rends compte que lorsque les capteurs fonctionnent déjà normalement, un fort taux de rayonnement global horaire conduit à la diminution de la qualité du fonctionnement du capteurs.


Question: est ce que les capteurs peuvent être affectées par les variations extrêmes du rayonnement, entrainant un dysfonctionnement pour des valeurs plus ou moins extrêmes?


```{r, message=FALSE, warning=FALSE}
ggplot(new_data(meteo, stop_sensor(liste_data_capteurs[[1]])) %>% filter(uptime_quality==TRUE), aes(x = GLO, y = uptime)) +
  geom_point(col="blue") +
  geom_smooth(method = "loess", col="yellow") +
  labs(title = "Relation entre le rayonnement global et le mauvais fonctionnement du capteur",
       x = "Rayonnement global horaire",
       y = "Fonctionnement du capteur", subtitle =unique(new_data(meteo, stop_sensor(liste_data_capteurs[[1]]))["segment_name"][[1]]) ) + guides(colour="none")
```

Ci dessus: Tendance générale de la qualité du capteur en fonction du taux de rayonnement horaire.


```{r}
for(i in seq_along(liste_data_capteurs)){
 plot(corrélation_uptime(new_data(meteo, stop_sensor(liste_data_capteurs[[i]])) %>% filter(uptime_quality==FALSE))[[2]])
}
```




# Analyse de corrélation sur les variables météo et l'ensemble des capteurs

+ avec filtre des données manquantes de type 2 (faisant varier le seuil definissant le type 2 de 25 à 50 pas de 5) mais sans suppression de données de la nuit

L'objectif étant de constater la nuances du résultat des corrélations avant et après suppression

```{r, echo=FALSE}
for(i in seq(25, 90, 5)){
  plot(corrélation_uptime(new_data(meteo, (NA_Type(sensors, threshold = i))) %>% filter(type==2))[[2]])
  paste0("Seuil de ", i, "%")
  
}

```

On remarque que plus on augmente le seuil plus les corrélation diminue mais faiblement

------------------

+ avec un filtre sur les valeurs manquantes de type 2 (faisant varier le seuil nous permettant de définir les valeurs manquantes de type 2 de 25 à 50 avec un pas de 5) et suppression des heures de nuit


```{r, message=FALSE, warning=FALSE, echo=FALSE}

for(i in seq(25, 50, 5)){
  plot(corrélation_uptime(new_data(meteo, stop_sensor(NA_Type(sensors, threshold = i), remove_data = TRUE, uptime_choice = 0.5)) %>% filter(type==2), liste_var_meteo = c("T", "U", "VV", "GLO"))[[2]])
}
```

La remarque reste la même que précédemment: plus on augmente le seuil plus les corrélation diminue mais faiblement, et à partir d'un certain seuil, les corrélations augmentes.



# Analyse de corrélation de l'ensemble des capteurs avec suppression des heures de nuit


```{r, message=FALSE, warning=FALSE, echo=FALSE}
plot(corrélation_uptime(new_data(meteo, stop_sensor(NA_Type(sensors))), liste_var_meteo = c("T", "U", "VV", "GLO"))[[2]])
```






# Analyse de corrélation de l'ensemble des capteurs avec un filtre sur les valeurs manquantes de type 2 et suppression des heures de nuit.


```{r, echo=FALSE}
plot(corrélation_uptime(new_data(meteo, stop_sensor(NA_Type(sensors), remove_data = TRUE, uptime_choice = 0.5)) %>% filter(type==2), liste_var_meteo = c("T", "U", "VV", "GLO"))[[2]])

```


Résultat similaire à l'analyse des capteurs de façon indépendantes: les NA de type 2 sont corrélées positivement au GLO pour ainsi traduire le fait que la qualité de fonctionnement de ces dernières tend à être meilleure pour des valeurs de rayonnement global horaire plus élevées.


```{r}
# Data frame de comparaison des corrélations de l'uptime en fontion de GLO dans des cas spécifiques

df_comparaison_glo1= corrélation_uptime(new_data(meteo, NA_Type(sensors)), liste_var_meteo = c("GLO"))[[1]]

df_comparaison_glo2 = corrélation_uptime(new_data(meteo, stop_sensor(NA_Type(sensors), uptime_choice = 0.5, remove_data = TRUE)), liste_var_meteo = c("GLO"))[[1]]

df_comparaison_glo3 = corrélation_uptime(new_data(meteo, stop_sensor(NA_Type(sensors, threshold = 50), remove_data = TRUE, uptime_choice = 0.5) %>% filter(type==2)), liste_var_meteo = c("GLO"))[[1]]

df_comparaison_glo4 = corrélation_uptime(new_data(meteo, stop_sensor(NA_Type(sensors, threshold = 50), remove_data = TRUE, uptime_choice = 0.5) %>% filter(uptime_quality == FALSE)), liste_var_meteo = c("GLO"))[[1]]

df_comparaison_glo5 = corrélation_uptime(new_data(meteo, stop_sensor(NA_Type(sensors, threshold = 50), remove_data = TRUE, uptime_choice = 0.5) %>% filter(uptime_quality == TRUE)), liste_var_meteo = c("GLO"))[[1]]

# Créer une nouvelle data frame pour la comparaison de ses valeurs
df_comparaison_glo = rbind(df_comparaison_glo1, df_comparaison_glo2, df_comparaison_glo3, df_comparaison_glo4, df_comparaison_glo5)


# modifier les noms des lignes
df_comparaison_glo[1,1] = "GLO_all_Sensors"
df_comparaison_glo[2,1] = "GLO_all_Sensors_no_Night"
df_comparaison_glo[3,1] = "GLO_all_Sensors_no_Night_filter2"
df_comparaison_glo[4,1] = "GLO_all_Sensors_no_Night_filterFALSE"
df_comparaison_glo[5,1] = "GLO_all_Sensors_no_Night_filterTRUE"

# Diagramme en barre pour la comparaison des corrélations avec les valeurs de GLO
ggplot(df_comparaison_glo, aes(x = Variable, y = Correlation, fill = Variable)) +
  geom_bar(stat = "identity") +
  labs(title = "Comparaison des corrélations de l'uptime et GLO dans des cas particuliers",
       x = "Cas particuliers",
       y = "Valeurs de corrélation") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
   geom_text(aes(label = round(Correlation, 2)), vjust = ifelse(df_comparaison_glo$Correlation>0, 1.4, -0.3), position = position_dodge(width = 0.9))+
  scale_fill_manual(values = c("green", "red", "yellow", "blue", "purple"))
```


Idée: pourquoi ne pas essayer de construire un modèle basé sur les variables météo qui explique au mieux l'uptime des capteurs?

```{r}
# Création d'un modèle de prédiction de l'uptime en fonction des variables météo

model1 = lm(uptime ~ T + U + VV + RR1 + GLO, data = new_data(meteo, stop_sensor(NA_Type(sensors, threshold = 50), remove_data = TRUE, uptime_choice = 0.5)))

summary(model1)


hist(residuals(model1))
```

A l'exception de la variable RR1, toutes les autres variables météo sont significatives pour expliquer l'uptime des capteurs. Cependant, la valeur de R2 ajustée obtenue est faible (0.04), ce qui indique que le modèle n'explique que 4% de la variabilité de l'uptime des capteurs qui en soi n'est pas suffisant pour tirer des conclusions significatives. Il semblerait que d'autres variables non considérées dans le modèle puissent jouer un rôle significatif dans l'explication de l'uptime des capteurs. 

Aussi, il s'agit là d'un test de significativité individuelle des variables. Il serait intéressant de tester la significativité globale du modèle.

```{r}
# Test de significité global du modèle

```


```{r}
model2 = lm(uptime ~ T + U + VV + GLO, data = new_data(meteo, stop_sensor(NA_Type(sensors, threshold = 50), remove_data = TRUE, uptime_choice = 0.5)))

summary(model2)


hist(residuals(model2))
```


Ayant extrait la variable RR1 qui fut non significative dans le modele 1, ce nouveau modèle n'explique toujours que 4% de la variabilité de l'uptime des capteurs. Il sera donc nécessaire de considérer d'autres variables pour expliquer l'uptime des capteurs.

```{r}
# Procedons à des tests de validation de nos modèles
c(AIC(model1), AIC(model2))
c(BIC(model1), BIC(model2))
```

Les valeurs de AIC et BIC sont plus faibles pour le modèle 1 que pour le modèle 2, ce qui indique que le modèle 1 est plus performant que le modèle 2. Cependant, les valeurs de ces critères restent élevées, ce qui indique que les modèles ne sont pas très performants pour expliquer l'uptime des capteurs.


```{r}
summary(lm(uptime ~  T + U + VV + RR1 + GLO + GLO:U + GLO:T, data = new_data(meteo, stop_sensor(NA_Type(sensors, threshold = 50), remove_data = TRUE, uptime_choice = 0.5))))

AIC(lm(uptime ~  T + U + VV + RR1 + GLO + GLO:U + GLO:T, data = new_data(meteo, stop_sensor(NA_Type(sensors, threshold = 50), remove_data = TRUE, uptime_choice = 0.5))))
```

------------------


# Analyse du comportement du trafic en fonction des variables météo


# Partie 2: Analyse de corrélation entre les différents modes de transport et les variables météo

```{r}
for(i in seq_along(liste_data_capteurs)){
  plot(correlation_traffic(new_data(meteo, stop_sensor(liste_data_capteurs[[i]]))))
}
```



# En semaine
```{r}
for(i in seq_along(liste_data_capteurs)){
  plot(correlation_traffic(new_data(meteo, stop_sensor(liste_data_capteurs[[i]])) %>% filter(weekday!="saturday" & weekday!="sunday")))
}

#correlation_traffic(new_data(meteo, stop_sensor(liste_data_capteurs[[2]])) %>% filter(weekday=="saturday" | weekday=="sunday"))

```



# En weekend

```{r}
for(i in seq_along(liste_data_capteurs)){
  plot(correlation_traffic(new_data(meteo, stop_sensor(liste_data_capteurs[[i]])) %>% filter(weekday=="saturday" | weekday=="sunday")))
}
```

# Période de vacances

```{r}
for(i in seq_along(liste_data_capteurs)){
  plot(correlation_traffic(new_data(meteo, stop_sensor(liste_data_capteurs[[i]])) %>% filter(holiday==TRUE)))
}
```



# Période de non vacances

```{r}
for(i in seq_along(liste_data_capteurs)){
  plot(correlation_traffic(new_data(meteo, stop_sensor(liste_data_capteurs[[i]])) %>% filter(holiday==FALSE)))
}

```


# Période d'été

```{r}
for(i in seq_along(liste_data_capteurs)){
  plot(correlation_traffic(new_data(meteo, stop_sensor(liste_data_capteurs[[ifelse(i==9, 10, i)]])) %>% filter(month(new_data(meteo, stop_sensor(liste_data_capteurs[[ifelse(i==9, 10, i)]]))$date.x) %in% c(6,7,8))))
}
```


# Période d'hiver
```{r}
for(i in seq_along(liste_data_capteurs)){
  plot(correlation_traffic(new_data(meteo, stop_sensor(liste_data_capteurs[[ifelse(i==i, i, i)]])) %>% filter(month(new_data(meteo, stop_sensor(liste_data_capteurs[[ifelse(i==i, i, i)]]))$date.x) %in% c(12,1,2))))
}
```


# Comportement global de tous les capteurs

```{r}
plot(correlation_traffic(new_data(meteo, stop_sensor(NA_Type(sensors, threshold = 50), remove_data = TRUE, uptime_choice = 0.5))))


```


# Données de nouveaux Capteurs V2

Les données sont enregistrées du 07 septembre 2023 au 16 mai 2024

```{r}
capteurs_V2 = quarterly_to_hourly(capteurs_V2)
```



# Nouvelle approche pour l'analyse de l'influence du climat sur la mobilité dans chateaubourg

## Y'a t-il une différence significative entre la moyenne de véhicule pendant les heures de pluies et les heures de non pluies?

Note: plus un seuil est élevé, plus l'heure considérée pluvieuse aura enregistré une quantité importante de pluie.

```{r, include=FALSE}
library(data.table)

#rm(weather_dat, V2_meteo, test_w)
V2_meteo = new_data(meteo, stop_sensor(capteurs_V2, remove_data = TRUE, uptime_choice = 0.5))

for(i in seuils){
  V2_meteo = V2_meteo %>% mutate(type_pluie = ifelse(RR1 > i, "pluie", "non pluie"))
  
  # Comparaison des moyennes de véhicules pendant les phases de pluie et de non pluie (variable concernée: type_pluie)
  # Creeons un tableau de comparaison des moyennes de véhicules pendant les phases de pluie et de non pluie
  
  # Véhicules
  print(V2_meteo %>% group_by(type_pluie) %>% summarise(mean_vehicule = mean(vehicule), n = n()) %>% data.table())
  # Vélos
  print(V2_meteo %>% group_by(type_pluie) %>% summarise(mean_bike = mean(bike), n = n()) %>% data.table())
  
}

```



On considèrera qu'il à plus si pour un seuil fixé, RR1 est supérieur à ce seuil.

Pour le test de significativité entre moyennes, nous disposons de deux options: 

+ le test t de Student et le test de Wilcoxon-Mann-Whitney. Le test t de Student est plus approprié pour les données normalement distribuées avec égalité de variances des 2 échantillons (par un test de Fisher: var.test()) 

+ Le test de Wilcoxon-Mann-Whitney est plus approprié pour les données non normalement distribuées ou encore normalement distribuées mais avec des variances différentes.

Ainsi, nous pouvons simplement tester l'hypothèse d'égalité de variance pour pouvoir choisir le test approprié.
   
    Après explorations, pour tous les seuils considérés, il n'y a pas de distribution normal de nos données (QQ-plot), de ce fait, on optera pour le test de Wilcoxon-Mann-Whitney
    
    Pour la suite, nous présenterons d'une part un tableau récapitulatif des p-value pour chaque seuil et d'autre part, un graphique de l'évolution de la moyenne des véhicules en fonction du seuil de pluie.
    
**Note**: 
    
  + p-value < 0.05 => différence significative entre les moyennes des véhicules des deux groupes (périodes de pluie et de non pluie)
    
  + p-value > 0.05 => pas de différence significative entre les moyennes des véhicules des deux groupes (périodes de pluie et de non pluie)


## Comparaison de la moyenne des véhicules en fonction du seuil de pluie sur les données des capteurs V2


```{r, echo=FALSE}

# Filtrage et catégorisation des données
V2_meteo <- V2_meteo %>%
  filter(!is.na(RR1))

# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 5, by = 0.5)
resultats <- data.frame(
  seuil = numeric(),
  condition = character(),
  moyenne_vehicule = numeric(),
  p_value = numeric()
)

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie"))
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyennes <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_vehicule = mean(vehicule, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_vehicule)
    
    # Effectuer le test t
    test_w <- wilcox.test(vehicule ~ pluie, data = V2_meteo_mod)
    
    # Ajouter les résultats du test t
    moyennes <- moyennes %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyennes)
  }
  
  
}

# Afficher les résultats
print(resultats)

# Création du graphique
ggplot(resultats,
       aes(
         x = seuil,
         y = moyenne_vehicule,
         color = condition,
         group = condition
       )) +
  geom_line() +
  geom_point() +
  labs(
    title = "Évolution de la moyenne des véhicules en fonction du seuil de pluie",
    x = "Seuil de pluie (mm)",
    y = "Moyenne des véhicules",
    color = "Condition"
  ) +
  theme_minimal()



```


+ ces résultats suggèrent (statistiquement) qu'il n'y a pas de différence significative entre les moyennes des véhicules des deux groupes (périodes de pluie et de non pluie) à l'exception du seuil 4.6, selon le test de Wilcoxon rank-sum.

+ A partir d'un certain seuil de précipitation plus élevé (traduisant le fais qu'on a plus de pluie), on observe que le nombre de véhicule en moyenne pendant les heures de pluie est plus élevé que pendant les heures de non pluie. Cela peut être dû au fait que les gens préfèrent utiliser leur véhicule personnel pour se déplacer lorsqu'il pleut. On s'attendrait à ce que le nombre de vélo diminue pendant les heures de pluie pour ces seuils.



## Comparaison de la moyenne des vélos en fonction du seuil de pluie par un test de Wilcoxon



```{r, evho=FALSE, "Comparaison de la moyenne des vélos en fonction du seuil de pluie par un test de Wilcoxon Capteurs V2"}
# Filtrage et catégorisation des données
V2_meteo <- V2_meteo %>%
  filter(!is.na(RR1))

# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(
  seuil = numeric(),
  condition = character(),
  moyenne_bike = numeric(),
  p_value = numeric()
)

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie"))
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyennes <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_bike = mean(bike, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_bike)
    
    # Effectuer le test t
    test_w <- wilcox.test(bike ~ pluie, data = V2_meteo_mod)
    
    # Ajouter les résultats du test t
    moyennes <- moyennes %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyennes)
  }
}



# Afficher les p-values pour chaque seuil
print(resultats %>% select(seuil, condition, p_value))

# Création du graphique
ggplot(resultats,
       aes(
         x = seuil,
         y = moyenne_bike,
         color = condition,
         group = condition
       )) +
  geom_line() +
  geom_point() +
  labs(
    title = "Évolution de la moyenne des vélos en fonction du seuil de pluie",
    x = "Seuil de pluie (mm)",
    y = "Moyenne des vélos",
    color = "Condition"
  ) +
  theme_minimal()


```


+ ces résultats suggèrent (statistiquement) qu'il y a une différence significative entre les moyennes des vélos des deux groupes (périodes de pluie et de non pluie) jusqu'au seuil 2.6 et après plus de différence significative. 

Toutefois, en observant le graphique, la différence de moyenne est plus grande à partir de 2.6, de ce fait on s'attendrait toujours à avoir une différence significative. Ce resultat contradictoire peut être dû au fait qu'à partir du seuil 2.6, le group des heures pluvieuses ne dispose pas de suffisamment de données pour effectuer une comparaison significative et ainsi la puissance du test de Wilcoxon est moins forte.


+ Toutefois, de l'analyse des moyennes de véhicules, on s'attendait à une diminution de la moyenne de vélos pendant les pluies pour les seuils à partir de 2.6; ce qui est le cas, mais cette moyenne de vélos augmente par la suite.



# Test sur les données de l'ensemble des capteurs V1 et V2

##Comparaison des moyennes de véhicules en fonction de seuils de précipitation (V1 et V2)

```{r, echo=FALSE}
sensors_meteo = new_data(meteo, stop_sensor(sensors, remove_data = TRUE, uptime_choice = 0.5))

```


```{r, echo=FALSE, "Comparaison des moyennes de véhicules en fonction de seuils de précipitation (V1 et V2)"}

# Filtrage et catégorisation des données
sensors_meteo <- sensors_meteo %>%
  filter(!is.na(RR1))

# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  sensors_meteo_mod <- sensors_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie"))
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(sensors_meteo_mod$pluie)) == 2) {
    moyenne <- sensors_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_vehicule = mean(vehicule, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_vehicule)
    
    # Effectuer le test t
    test_w <- wilcox.test(vehicule ~ pluie, data = sensors_meteo_mod)
    
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
ggplot(resultats, aes(x = seuil, y = moyenne_vehicule, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des véhicules en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des véhicules",
       color = "Condition") +
  theme_minimal()


```


On observe le même comportement et en plus on remarque pour le seuil 5.6 on a une diminution de la moyenne de véhicule pendant la pluie. Cela peut être dû au fait que certains conducteurs par mesure de sécurité lorsqu'il pleut beaucoup préfèrent ne pas sortir avec leur véhicule ou tout simplement se garer à un endroit sûr.

## Comparaison des moyennes de vélos en fonction de seuils de précipitation (V1 et V2)


```{r, echo=FALSE, "Comparaison des moyennes de vélos en fonction de seuils de précipitation (V1 et V2)"}
# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  sensors_meteo_mod <- sensors_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie"))
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(sensors_meteo_mod$pluie)) == 2) {
    moyenne <- sensors_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_velo = mean(bike, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_velo)
    
    # Effectuer le test t
    test_w <- wilcox.test(bike ~ pluie, data = sensors_meteo_mod)
   
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(data.table(resultats))

# Création du graphique
ggplot(resultats, aes(x = seuil, y = moyenne_velo, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des vélos en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des vélos",
       color = "Condition") +
  theme_minimal()

```

On constate que le comportement pour ces données est complètement opposé à celui des données unique des capteurs V2.


## Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le matin (7h et 8h) et en semaine

Le 1er tableau présente les résultats pour les vélos et le 2ème pour les véhicules et en 3e position nous avons le graphique nous permettant de visualiser l'évolution de la moyenne des vélos et des véhicules en fonction du seuil de pluie.

```{r, echo=FALSE, "Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le matin (7h et 8h) et en semaine"}

# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  sensors_meteo_mod <- sensors_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(7, 8) & weekday %in% c("monday", "tuesday", "wednesday", "thursday", "friday"))
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(sensors_meteo_mod$pluie)) == 2) {
    moyenne <- sensors_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_velo = mean(bike, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_velo)
    
    # Effectuer le test t
    test_w <- wilcox.test(bike ~ pluie, data = sensors_meteo_mod)
   
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
p = ggplot(resultats, aes(x = seuil, y = moyenne_velo, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des vélos en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des vélos",
       color = "Condition") +
  theme_minimal()


# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  sensors_meteo_mod <- sensors_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(7, 8) & weekday %in% c("monday", "tuesday", "wednesday", "thursday", "friday"))
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(sensors_meteo_mod$pluie)) == 2) {
    moyenne <- sensors_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_vehicule = mean(vehicule, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_vehicule)
    
    # Effectuer le test t
    test_w <- wilcox.test(vehicule ~ pluie, data = sensors_meteo_mod)
   
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
q = ggplot(resultats, aes(x = seuil, y = moyenne_vehicule, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des véhicules en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des véhicules",
       color = "Condition") +
  theme_minimal()

gridExtra::grid.arrange(p, q, ncol = 2)
```


## Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le SOIR (17h et 18h) et en semaine

```{r, echo=FALSE, "Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le SOIR (17h et 18h) et en semaine"}
# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  sensors_meteo_mod <- sensors_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(17, 18) & weekday %in% c("monday", "tuesday", "wednesday", "thursday", "friday"))
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(sensors_meteo_mod$pluie)) == 2) {
    moyenne <- sensors_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_velo = mean(bike, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_velo)
    
    # Effectuer le test t
    test_w <- wilcox.test(bike ~ pluie, data = sensors_meteo_mod)
    
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
p = ggplot(resultats, aes(x = seuil, y = moyenne_velo, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des vélos en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des vélos",
       color = "Condition") +
  theme_minimal()


# Initialisation des seuils et du tableau pour les résultats
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  sensors_meteo_mod <- sensors_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(17, 18) & weekday %in% c("monday", "tuesday", "wednesday", "thursday", "friday"))
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(sensors_meteo_mod$pluie)) == 2) {
    moyenne <- sensors_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_vehicule = mean(vehicule, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_vehicule)
    
    # Effectuer le test t
    test_w <- wilcox.test(vehicule ~ pluie, data = sensors_meteo_mod)
   
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
q = ggplot(resultats, aes(x = seuil, y = moyenne_vehicule, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des véhicules en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des véhicules",
       color = "Condition") +
  theme_minimal()

gridExtra::grid.arrange(p, q, ncol = 2)
```


## Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le matin (7h et 8h) et en semaine


Le 1er tableau présente les résultats pour les vélos et le 2ème pour les véhicules et en 3e position nous avons le graphique nous permettant de visualiser l'évolution de la moyenne des vélos et des véhicules en fonction du seuil de pluie.


```{r, echo=FALSE, message=FALSE, "Comparaison de la moyenne des vélos puis des véhicules"}

# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  sensors_meteo_mod <- sensors_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(7, 8) & weekday %in% c("monday", "tuesday", "wednesday", "thursday", "friday"))
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(sensors_meteo_mod$pluie)) == 2) {
    moyenne <- sensors_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_velo = mean(bike, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_velo)
    
    # Effectuer le test t
    test_w <- wilcox.test(bike ~ pluie, data = sensors_meteo_mod)
   
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
p = ggplot(resultats, aes(x = seuil, y = moyenne_velo, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des vélos en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des vélos",
       color = "Condition") +
  theme_minimal()


# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  sensors_meteo_mod <- sensors_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(7, 8) & weekday %in% c("monday", "tuesday", "wednesday", "thursday", "friday"))
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(sensors_meteo_mod$pluie)) == 2) {
    moyenne <- sensors_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_vehicule = mean(vehicule, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_vehicule)
    
    # Effectuer le test t
    test_w <- wilcox.test(vehicule ~ pluie, data = sensors_meteo_mod)
   
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
q = ggplot(resultats, aes(x = seuil, y = moyenne_vehicule, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des véhicules en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des véhicules",
       color = "Condition") +
  theme_minimal()

gridExtra::grid.arrange(p, q, ncol = 2)
```


## Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le SOIR (17h et 18h) et en semaine

```{r, echo=FALSE, message=FALSE}
# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  sensors_meteo_mod <- sensors_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(17, 18) & weekday %in% c("monday", "tuesday", "wednesday", "thursday", "friday"))
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(sensors_meteo_mod$pluie)) == 2) {
    moyenne <- sensors_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_velo = mean(bike, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_velo)
    
    # Effectuer le test t
    test_w <- wilcox.test(bike ~ pluie, data = sensors_meteo_mod)
    
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
p = ggplot(resultats, aes(x = seuil, y = moyenne_velo, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des vélos en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des vélos",
       color = "Condition") +
  theme_minimal()


# Initialisation des seuils et du tableau pour les résultats
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  sensors_meteo_mod <- sensors_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(17, 18) & weekday %in% c("monday", "tuesday", "wednesday", "thursday", "friday"))
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(sensors_meteo_mod$pluie)) == 2) {
    moyenne <- sensors_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_vehicule = mean(vehicule, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_vehicule)
    
    # Effectuer le test t
    test_w <- wilcox.test(vehicule ~ pluie, data = sensors_meteo_mod)
   
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
q = ggplot(resultats, aes(x = seuil, y = moyenne_vehicule, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des véhicules en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des véhicules",
       color = "Condition") +
  theme_minimal()

gridExtra::grid.arrange(p, q, ncol = 2)
```


# Même analyse en filtrant tout d'abors sur la période scolaire (holiday=FALSE) et en semaine

## Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le matin (7h et 8h), en semaine et pendant la période scolaire

```{r, echo=FALSE, message=FALSE}
# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_velo = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  sensors_meteo_mod <- sensors_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(7, 8) & weekday %in% c("monday", "tuesday", "wednesday", "thursday", "friday") & holiday==FALSE)
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(sensors_meteo_mod$pluie)) == 2) {
    moyenne <- sensors_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_velo = mean(bike, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_velo)
    
    # Effectuer le test t
    test_w <- wilcox.test(bike ~ pluie, data = sensors_meteo_mod)
    
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
p = ggplot(resultats, aes(x = seuil, y = moyenne_velo, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des vélos en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des vélos",
       color = "Condition") +
  theme_minimal()

resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  sensors_meteo_mod <- sensors_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(7, 8) & weekday %in% c("monday", "tuesday", "wednesday", "thursday", "friday") & holiday==FALSE)
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(sensors_meteo_mod$pluie)) == 2) {
    moyenne <- sensors_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_vehicule = mean(vehicule, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_vehicule)
    
    # Effectuer le test t
    test_w <- wilcox.test(vehicule ~ pluie, data = sensors_meteo_mod)
    
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
q = ggplot(resultats, aes(x = seuil, y = moyenne_vehicule, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des véhicules en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des véhicules",
       color = "Condition") +
  theme_minimal()

gridExtra::grid.arrange(p, q, ncol = 2)
```


## Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le SOIR (17h et 18h), en semaine et pendant la période scolaire

```{r, echo=FALSE, message=FALSE}
# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  sensors_meteo_mod <- sensors_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(17, 18) & weekday %in% c("monday", "tuesday", "wednesday", "thursday", "friday") & holiday==FALSE)
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(sensors_meteo_mod$pluie)) == 2) {
    moyenne <- sensors_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_velo = mean(bike, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_velo)
    
    # Effectuer le test t
    test_w <- wilcox.test(bike ~ pluie, data = sensors_meteo_mod)

    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
ggplot(resultats, aes(x = seuil, y = moyenne_velo, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des vélos en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des vélos",
       color = "Condition") +
  theme_minimal()
```


# Même analyse en filtrant tout d'abors sur la période non scolaire (holiday=TRUE) et en semaine

## Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le matin (7h et 8h), en semaine et pendant la période non scolaire

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  sensors_meteo_mod <- sensors_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(7, 8) & weekday %in% c("monday", "tuesday", "wednesday", "thursday", "friday") & holiday==TRUE)
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(sensors_meteo_mod$pluie)) == 2) {
    moyenne <- sensors_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_velo = mean(bike, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_velo)
    
    # Effectuer le test t
    test_w <- wilcox.test(bike ~ pluie, data = sensors_meteo_mod)
    
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
ggplot(resultats, aes(x = seuil, y = moyenne_velo, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des véhicules en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des véhicules",
       color = "Condition") +
  theme_minimal()
```

## Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le SOIR (17h et 18h), en semaine et pendant la période non scolaire


```{r, echo=FALSE}
# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  sensors_meteo_mod <- sensors_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(17, 18, 19) & weekday %in% c("monday", "tuesday", "wednesday", "thursday", "friday") & holiday==TRUE)
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(sensors_meteo_mod$pluie)) == 2) {
    moyenne <- sensors_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_velo = mean(bike, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_velo)
    
    # Effectuer le test t
    test_w <- wilcox.test(bike ~ pluie, data = sensors_meteo_mod)
    
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
ggplot(resultats, aes(x = seuil, y = moyenne_velo, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des vélos en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des vélos",
       color = "Condition") +
  theme_minimal()
```






```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(
  seuil = numeric(),
  condition = character(),
  moyenne_vehicule = numeric(),
  p_value = numeric()
)

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  sensors_meteo_mod <- sensors_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie"))
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(sensors_meteo_mod$pluie)) == 2) {
    moyenne <- sensors_meteo_mod %>%
      group_by(pluie) %>%
      summarise(
        total_velo = sum(bike, na.rm = TRUE),
        total_trafic = sum(vehicule + bike, na.rm = TRUE)
      ) %>%
      mutate(rapport_velo = total_velo / total_trafic) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, rapport_velo)
    
    # Effectuer le test t
    test_w <- wilcox.test(bike ~ pluie, data = sensors_meteo_mod)
    
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(data.table(resultats))

# Création du graphique
p = ggplot(resultats,
           aes(
             x = seuil,
             y = rapport_velo,
             color = condition,
             group = condition
           )) +
  geom_line() +
  geom_point() +
  labs(
    title = "Évolution de la moyenne des vélos en fonction du seuil de pluie",
    x = "Seuil de pluie (mm)",
    y = "Moyenne des vélos",
    color = "Condition"
  ) +
  theme_minimal()


# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(
  seuil = numeric(),
  condition = character(),
  moyenne_vehicule = numeric(),
  p_value = numeric()
)

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  sensors_meteo_mod <- sensors_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie"))
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(sensors_meteo_mod$pluie)) == 2) {
    moyenne <- sensors_meteo_mod %>%
      group_by(pluie) %>%
      summarise(
        total_vehicule = sum(vehicule, na.rm = TRUE),
        total_trafic = sum(vehicule + bike, na.rm = TRUE)
      ) %>%
      mutate(rapport_vehicule = total_vehicule / total_trafic) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, rapport_vehicule)
    
    # Effectuer le test t
    test_w <- wilcox.test(vehicule ~ pluie, data = sensors_meteo_mod)
    
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(data.table(resultats))

# Création du graphique
q = ggplot(resultats,
           aes(
             x = seuil,
             y = rapport_vehicule,
             color = condition,
             group = condition
           )) +
  geom_line() +
  geom_point() +
  labs(
    title = "Évolution de la moyenne des véhicules en fonction du seuil de pluie",
    x = "Seuil de pluie (mm)",
    y = "Moyenne des véhicules",
    color = "Condition"
  ) +
  theme_minimal()


gridExtra::grid.arrange(p, q, ncol = 2)
```


**J'aimerais répondre à la question suivante: par rapport au trafic total observé en une journée, à t-on eu une diminution du trafic de vélos lorsqu'il pleuvait et une augmentation de véhicules ?**

Pour une analyse plus pertinente de l'influence de la météo sur le trafic, il est possible de combiner différentes approches, notamment l'analyse des proportions et des moyennes, en incluant des analyses temporelles et des tests statistiques pour confirmer les observations.


```{r, echo=FALSE, message=FALSE, warning=FALSE}
compare_traffic_ratios <- function(data, seuil_precipitation = 2.5) {
  data_meteo = new_data(meteo, data_mouv = data)
  # Vérification que les colonnes nécessaires sont présentes
  required_columns <- c("date", "RR1", "bike", "vehicule", "day")
  if (!all(required_columns %in% colnames(data_meteo))) {
    stop(
      "Le jeu de données doit contenir les colonnes suivantes : 'date', 'RR1', 'bike', 'vehicule'"
    )
  }
  
  # conserver les données où il a plu au moins une fois en une journée
  
  days_with_rain <- data_meteo %>%
    group_by(date) %>%
    filter(RR1 > seuil_precipitation) %>%
    ungroup() %>%
    left_join(
      data_meteo,
      by = "day",
      suffix = c("_rain", ""),
      relationship = "many-to-many"
    ) %>%
    select(!ends_with("rain")) %>%
    mutate(pluie = ifelse(RR1 > seuil_precipitation, "pluie", "non pluie"))
  
  # calculer les totaux horaires pour chaque condition par jour
  totaux_horaires <- days_with_rain %>%
    group_by(day, pluie) %>%
    summarise(
      total_bike = sum(bike, na.rm = TRUE),
      total_vehicule = sum(vehicule, na.rm = TRUE),
      total_trafic = sum(total_bike + total_vehicule),
      .groups = "keep"
    ) %>%
    mutate(
      rapport_vehicule = total_vehicule / total_trafic,
      rapport_velo = total_bike / total_trafic,
      condition = pluie,
      date = day
    ) %>%
    ungroup() %>%
    select(date, pluie, rapport_vehicule, rapport_velo)
  
  # graphique pour les vélos avec des lignes de couleurs différentes
  plot_bike <- ggplot(totaux_horaires,
                      aes(
                        x = date,
                        y = rapport_velo,
                        color = pluie,
                        group = 1
                      )) +
    geom_point() +
    geom_line() +
    scale_color_manual(values = c("pluie" = "red", "non pluie" = "blue")) +
    labs(title = "Rapport des vélos pendant les périodes de pluie et de non pluie", x = "Date", y = "Rapport des vélos") +
    theme_minimal() + theme(axis.text.x = element_text(
      angle = 90,
      vjust = 0.5,
      hjust = 1,
      colour = ifelse(totaux_horaires$date %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday"), "green", "purple")
    ))
  
  # graphique pour les voitures avec des lignes de couleurs différentes
  plot_vehicule <- ggplot(totaux_horaires,
                          aes(
                            x = date,
                            y = rapport_vehicule,
                            color = pluie,
                            group = 1
                          )) +
    geom_point() +
    geom_line() +
    scale_color_manual(values = c("pluie" = "red", "non pluie" = "blue")) +
    labs(title = "Rapport des véhicules pendant les périodes de pluie et de non pluie", x = "Date", y = "Rapport des véhicules") +
    theme_minimal() +
    theme(axis.text.x = element_text(
      angle = 90,
      vjust = 0.5,
      hjust = 1,
      colour = ifelse(totaux_horaires$date %in% c("Saturday", "Sunday"), "green", "purple")
    )
    )
  
  
  
  
  # Afficher le graphique
  return(gridExtra::grid.arrange(plot_bike, plot_vehicule, ncol = 2))
}

# Utilisation de la fonction avec un jeu de données
capteurs_V2 = quarterly_to_hourly(capteurs_V2)
capteurs_V2 = stop_sensor(capteurs_V2,
                          uptime_choice = 0.5,
                          remove_data = TRUE)
compare_traffic_ratios(capteurs_V2, seuil_precipitation = 1.5)


```



```{r, echo=FALSE, message=FALSE, warning=FALSE}
# comparer en une journée le rapport de vélos / trafic total quand il a plu ce jour et le rapport des vélos quand il n'a pas plus; juxtaposer le graphique avec la même comparaison mais plutot pour les voiture

# conserver les données où il a plu au moins une fois en une journée
days_with_rain <- V2_meteo %>%
  group_by(date) %>%
  filter(RR1 > 3.1) %>%
  ungroup() %>%
  left_join(
    V2_meteo,
    by = "day",
    suffix = c("_rain", ""),
    relationship = "many-to-many"
  ) %>%
  select(!ends_with("rain")) %>%
  mutate(pluie = ifelse(RR1 > 3.1, "pluie", "non pluie"))

# calculer les totaux horaires pour chaque condition par jour
totaux_horaires <- days_with_rain %>%
  group_by(day, pluie) %>%
  summarise(
    total_bike = sum(bike, na.rm = TRUE),
    total_vehicule = sum(vehicule, na.rm = TRUE),
    total_trafic = sum(total_bike + total_vehicule)
  ) %>%
  mutate(
    rapport_vehicule = total_vehicule / total_trafic,
    rapport_velo = total_bike / total_trafic,
    condition = pluie,
    date = day
  ) %>%
  ungroup() %>%
  select(date, pluie, rapport_vehicule, rapport_velo)

# graphique pour les vélos avec des lignes de couleurs différentes
plot_bike <- ggplot(totaux_horaires,
                    aes(
                      x = date,
                      y = rapport_velo,
                      group = pluie,
                      color = pluie
                    )) +
  geom_point() +
  geom_line(aes(color = pluie)) +
  scale_color_manual(values = c("pluie" = "red", "non pluie" = "blue")) +
  labs(title = "Rapport des vélos pendant les périodes de pluie et de non pluie", x = "Date", y = "Rapport des vélos") +
  theme_minimal() + theme(axis.text.x = element_text(
    angle = 90,
    vjust = 0.5,
    hjust = 1
  ))

# graphique pour les voitures avec des lignes de couleurs différentes
plot_vehicule <- ggplot(totaux_horaires,
                        aes(
                          x = date,
                          y = rapport_vehicule,
                          group = pluie,
                          color = pluie
                        )) +
  geom_point() +
  geom_line(aes(color = pluie)) +
  scale_color_manual(values = c("pluie" = "red", "non pluie" = "blue")) +
  labs(title = "Rapport des véhicules pendant les périodes de pluie et de non pluie", x = "Date", y = "Rapport des véhicules") +
  theme_minimal() +
  theme(axis.text.x = element_text(
    angle = 90,
    vjust = 0.5,
    hjust = 1
  ))


gridExtra::grid.arrange(plot_bike, plot_vehicule, ncol = 2)
```




```{r, echo=FALSE, message=FALSE, warning=FALSE}
m = V2_meteo %>%
  group_by(date) %>%
    filter(RR1 > 3.1) %>%
     ungroup() %>% 
       left_join(V2_meteo, by = "day", suffix = c("_rain", ""), relationship = "many-to-many") %>%
        select(!ends_with("rain")) %>% 
          mutate(pluie = ifelse(RR1 > 3.1, "pluie", "non pluie")) %>% 
            ggplot(aes(x = bike, fill = pluie)) +
              geom_density(alpha = 0.5) + facet_wrap(~pluie) +
  labs(title = "Densité des vélos en fonction de la pluie", x = "Vélos", fill = "Pluie") +
  theme_minimal() + theme(legend.position = "top")
ggplotly(m)
#  + geom_density(aes(x = vehicule, fill = pluie), alpha = 0.5) + labs(title = "Densité des véhicules en fonction de la pluie", x = "Véhicules", fill = "Pluie") + theme_minimal() + theme(legend.position = "top") + facet_wrap(~pluie) + geom_density(aes(x = bike, fill = pluie), alpha = 0.5) + labs(title = "Densité des vélos en fonction de la pluie", x = "Vélos", fill = "Pluie") + theme_minimal() + theme(legend.position = "top") + facet_wrap(~pluie) + geom_density(aes(x = vehicule, fill = pluie), alpha = 0.5) + labs(title = "Densité des véhicules en fonction de la pluie", x = "Véhicules", fill = "Pluie") + theme_minimal() + theme(legend.position = "top") + facet_wrap(~pluie)

days_with_rain %>% 
  group_by(day, pluie) %>%
    summarise(total_bike = sum(bike, na.rm = TRUE),
              total_vehicule = sum(vehicule, na.rm = TRUE),
              total_trafic = sum(total_bike + total_vehicule)) %>%
      mutate(rapport_vehicule = total_vehicule/total_trafic,
             rapport_velo = total_bike/total_trafic,
             condition = pluie,
             date = day) %>%
        ungroup() %>% 
          select(date, pluie, rapport_vehicule,total_vehicule, rapport_velo, total_bike, total_trafic)

ggplot(capteurs_V2, aes(x = bike)) +
  geom_histogram(fill="yellow")  +
  labs(title = "Densité des vélos en fonction de la pluie", x = "Vélos", fill = "Pluie") +
  theme_minimal() + theme(legend.position = "top")
```



# Exploration des données de vélos et véhicule (car) pour les capteurs V1

L'objectif est de pouvoir trouver une explication au comportement des vélos lorsqu'il pleut (augmentation de la moyenne de vélos): A -t on une grande proportion de valeur abérantes de vélos lorsqu'il pleut ? Si oui, qu'en est il des véhicules ?

```{r, echo=FALSE, message=FALSE, warning=FALSE}

# Boxplot pour les périodes de pluie: valeurs abérantes de vélos ? avec un seuil de 0.6 et un titre de graphique
new_data(meteo, sensors) %>% filter(RR1 > 0.6)%>% ggplot(aes(y=bike, x=day)) + geom_boxplot() + geom_text(aes(label = ifelse(bike>200,round(bike), "")), vjust = 0, hjust = 0) + labs(title = "Boxplot des vélos pour les périodes de pluie (V1)", x = "Jour", y = "Vélos")

# Boxplot pour les périodes de pluie: valeurs abérantes de véhicules ? avec un seuil de 0.6 et un titre de graphique
new_data(meteo, sensors) %>% filter(RR1 > 0.6)%>% ggplot(aes(y=car, x=day)) + geom_boxplot() + geom_text(aes(label = ifelse(car>900,round(car), "")), vjust = 0, hjust = 0) + labs(title = "Boxplot des véhicules pour les périodes de pluie (V1)", x = "Jour", y = "Véhicules")


# Boxplot pour les périodes de pluie: valeurs abérantes de vélos ? avec un seuil de 0.6 et un titre de graphique
new_data(meteo, capteurs_V2) %>% filter(RR1 > 0.6)%>% ggplot(aes(y=bike, x=day)) + geom_boxplot() + geom_text(aes(label = ifelse(bike>200,round(bike), "")), vjust = 0, hjust = 0) + labs(title = "Boxplot des vélos pour les périodes de pluie (V2)", x = "Jour", y = "Vélos")

# Boxplot pour les périodes de pluie: valeurs abérantes de véhicules ? avec un seuil de 0.6 et un titre de graphique
new_data(meteo, capteurs_V2) %>% filter(RR1 > 0.6)%>% ggplot(aes(y=car, x=day)) + geom_boxplot() + geom_text(aes(label = ifelse(car>900,round(car), "")), vjust = 0, hjust = 0) + labs(title = "Boxplot des véhicules pour les périodes de pluie (V2)", x = "Jour", y = "Véhicules")


# Boxplot pour les périodes de pluie: valeurs abérantes de véhicules ? avec un seuil de 0.6 et un titre de graphique
new_data(meteo, capteurs_V2) %>% filter(RR1 > 0.6)%>% ggplot(aes(y=pedestrian, x=day)) + geom_boxplot() + labs(title = "Boxplot des piétons pour les périodes de pluie (V2)", x = "Jour", y = "Véhicules")

```


# Conclusion
Nous avons pu constater que les valeurs abérantes de vélos sont plus fréquentes pour les capteurs V1 que pour les capteurs V2. Cela pourrait expliquer l'augmentation de la moyenne de vélos lorsqu'il pleut pour les capteurs V1. L'utilisation des données des capteurs V1 semble apporter de grands biais qui rend difficile l'interprétation des résultats.

De ce fait, nous allons nous concentrer sur les capteurs V2 pour la suite de l'analyse.


# Test sur les données de l'ensemble des capteurs V2


```{r, echo=FALSE, message=FALSE, warning=FALSE}
capteurs_V2 = read.csv("data/20230518_20240517_v2_sensors_extract.csv", sep=",", header=TRUE)
capteurs_V2 = quarterly_to_hourly(capteurs_V2)
capteurs_V2 = stop_sensor(capteurs_V2, uptime_choice = 0.5, remove_data = TRUE)
V2_meteo = new_data(meteo, capteurs_V2)
```



## Comparaison des moyennes de vélos et de véhicules en fonction de seuils de précipitation (V2)


```{r, echo=FALSE, message=FALSE, warning=FALSE, "Comparaison des moyennes de vélos en fonction de seuils de précipitation (V2)"}
# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie"))
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_velo = mean(bike, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_velo)
    
    # Effectuer le test t
    test_w <- wilcox.test(bike ~ pluie, data = V2_meteo_mod)
   
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(data.table(resultats))

# Création du graphique
p = ggplot(resultats, aes(x = seuil, y = moyenne_velo, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des vélos en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des vélos",
       color = "Condition") +
  theme_minimal()

# Filtrage et catégorisation des données
V2_meteo <- V2_meteo %>%
  filter(!is.na(RR1))

# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie"))
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_vehicule = mean(vehicule, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_vehicule)
    
    # Effectuer le test t
    test_w <- wilcox.test(vehicule ~ pluie, data = V2_meteo_mod)
    
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
q = ggplot(resultats, aes(x = seuil, y = moyenne_vehicule, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des véhicules en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des véhicules",
       color = "Condition") +
  theme_minimal()


gridExtra::grid.arrange(p, q, ncol = 2)

# suppression des variables qui ont été créées dans cette section afin de libérer de l'espace mémoire
rm(seuils, resultats, p, q, V2_meteo_mod, test_w, moyenne)
```

 + Pour les **Véhicules**, on remarque que pour le seuil 5.6 on a une diminution de la moyenne de véhicule pendant la pluie. Cela peut être dû au fait que certains conducteurs par mesure de sécurité lorsqu'il pleut beaucoup préfèrent ne pas sortir avec leur véhicule ou tout simplement se garer à un endroit sûr. Et avec des pluies moins fortes, on a plus de circulation de véhicules par rapport à la circulation habituelle.
 
 + Pour les **Vélos**, on remarque qu'il y a une moyenne moins importante de vélos lorsqu'il pleut. Cela peut être dû au fait que les cyclistes préfèrent ne pas sortir lorsqu'il pleut ou tout simplement que les conditions climatiques ne sont pas favorables pour eux. Pour un seuil de précipitation de 5.6 et plus, on remarque une hausse de la moyenne pendant les pluie; toutefois on n'est toujours en dessous de la moyenne de vélos observées lorsqu'il ne pleut pas.

----------

## Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le matin (7h et 8h) et en semaine

Le 1er tableau présente les résultats pour les vélos et le 2ème pour les véhicules et en 3e position nous avons le graphique nous permettant de visualiser l'évolution de la moyenne des vélos et des véhicules en fonction du seuil de pluie.

```{r, echo=FALSE, "Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le matin (7h et 8h) et en semaine"}

# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(7, 8) & weekday %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday"))
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_velo = mean(bike, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_velo)
    
    # Effectuer le test t
    test_w <- wilcox.test(bike ~ pluie, data = V2_meteo_mod)
   
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
p = ggplot(resultats, aes(x = seuil, y = moyenne_velo, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des vélos en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des vélos",
       color = "Condition") +
  theme_minimal()


# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(7, 8) & weekday %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday"))
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_vehicule = mean(vehicule, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_vehicule)
    
    # Effectuer le test t
    test_w <- wilcox.test(vehicule ~ pluie, data = V2_meteo_mod)
   
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
q = ggplot(resultats, aes(x = seuil, y = moyenne_vehicule, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des véhicules en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des véhicules",
       color = "Condition") +
  theme_minimal()

gridExtra::grid.arrange(p, q, ncol = 2)


rm(seuils, resultats, p, q, V2_meteo_mod, test_w, moyenne)
```


## Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le SOIR (17h et 18h) et en semaine

```{r, echo=FALSE, "Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le SOIR (17h et 18h) et en semaine"}

# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(17, 18) & weekday %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday"))
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
        summarise(moyenne_velo = mean(bike, na.rm = TRUE)) %>%
          mutate(seuil = i, condition = pluie) %>%
            select(seuil, condition, moyenne_velo)
    
    # Effectuer le test t
    test_w <- wilcox.test(bike ~ pluie, data = V2_meteo_mod)
    
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
p = ggplot(resultats, aes(x = seuil, y = moyenne_velo, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
    labs(title = "Évolution de la moyenne des vélos en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des vélos",
       color = "Condition") +
  theme_minimal()


# Initialisation des seuils et du tableau pour les résultats
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(
    hour %in% c(17, 18) &
      weekday %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday")
  )
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_vehicule = mean(vehicule, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_vehicule)
    
    # Effectuer le test t
    test_w <- wilcox.test(vehicule ~ pluie, data = V2_meteo_mod)
    
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
q = ggplot(resultats, aes(x = seuil, y = moyenne_vehicule, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des véhicules en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des véhicules",
       color = "Condition") +
  theme_minimal()

gridExtra::grid.arrange(p, q, ncol = 2)


rm(seuils, resultats, p, q, V2_meteo_mod, test_w, moyenne)
```


## Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le matin (7h et 8h) et en semaine


Le 1er tableau présente les résultats pour les vélos et le 2ème pour les véhicules et en 3e position nous avons le graphique nous permettant de visualiser l'évolution de la moyenne des vélos et des véhicules en fonction du seuil de pluie.


```{r, echo=FALSE, message=FALSE, "Comparaison de la moyenne des vélos puis des véhicules"}

# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(7, 8) & weekday %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday"))
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_velo = mean(bike, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_velo)
    
    # Effectuer le test t
    test_w <- wilcox.test(bike ~ pluie, data = V2_meteo_mod)
   
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
p = ggplot(resultats, aes(x = seuil, y = moyenne_velo, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des vélos en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des vélos",
       color = "Condition") +
  theme_minimal()


# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(7, 8) & weekday %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday"))
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_vehicule = mean(vehicule, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_vehicule)
    
    # Effectuer le test t
    test_w <- wilcox.test(vehicule ~ pluie, data = V2_meteo_mod)
   
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
q = ggplot(resultats, aes(x = seuil, y = moyenne_vehicule, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des véhicules en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des véhicules",
       color = "Condition") +
  theme_minimal()

gridExtra::grid.arrange(p, q, ncol = 2)


# suppression des variables qui viennent d'être créées pour libérer de la mémoire
rm(resultats, p, q, seuils, V2_meteo_mod, moyenne, test_w)
```


## Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le SOIR (17h et 18h) et en semaine

```{r, echo=FALSE, message=FALSE}
# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(17, 18) & weekday %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday"))
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_velo = mean(bike, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_velo)
    
    # Effectuer le test t
    test_w <- wilcox.test(bike ~ pluie, data = V2_meteo_mod)
    
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
p = ggplot(resultats, aes(x = seuil, y = moyenne_velo, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des vélos en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des vélos",
       color = "Condition") +
  theme_minimal()


# Initialisation des seuils et du tableau pour les résultats
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(17, 18) & weekday %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday"))
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_vehicule = mean(vehicule, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_vehicule)
    
    # Effectuer le test t
    test_w <- wilcox.test(vehicule ~ pluie, data = V2_meteo_mod)
   
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
q = ggplot(resultats, aes(x = seuil, y = moyenne_vehicule, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des véhicules en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des véhicules",
       color = "Condition") +
  theme_minimal()

gridExtra::grid.arrange(p, q, ncol = 2)


# suppression des variables qui viennent d'être créées pour libérer de la mémoire
rm(resultats, p, q, seuils, V2_meteo_mod, moyenne, test_w)
```


# Même analyse en filtrant tout d'abors sur la période scolaire (holiday=FALSE) et en semaine

## Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le matin (7h et 8h), en semaine et pendant la période scolaire

```{r, echo=FALSE, message=FALSE}
# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_velo = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(7, 8) & weekday %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday") & holiday==FALSE)
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_velo = mean(bike, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_velo)
    
    # Effectuer le test t
    test_w <- wilcox.test(bike ~ pluie, data = V2_meteo_mod)
    
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
p = ggplot(resultats, aes(x = seuil, y = moyenne_velo, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des vélos en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des vélos",
       color = "Condition") +
  theme_minimal()

resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(7, 8) & weekday %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday") & holiday==FALSE)
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_vehicule = mean(vehicule, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_vehicule)
    
    # Effectuer le test t
    test_w <- wilcox.test(vehicule ~ pluie, data = V2_meteo_mod)
    
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
q = ggplot(resultats, aes(x = seuil, y = moyenne_vehicule, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des véhicules en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des véhicules",
       color = "Condition") +
  theme_minimal()

gridExtra::grid.arrange(p, q, ncol = 2)


# suppression des variables qui viennent d'être créées pour libérer de la mémoire
rm(resultats, p, q, seuils, V2_meteo_mod, moyenne, test_w)
```


## Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le SOIR (17h et 18h), en semaine et pendant la période scolaire

```{r, echo=FALSE, message=FALSE}
# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(17, 18) & weekday %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday") & holiday==FALSE)
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_velo = mean(bike, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_velo)
    
    # Effectuer le test t
    test_w <- wilcox.test(bike ~ pluie, data = V2_meteo_mod)

    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
p = ggplot(resultats, aes(x = seuil, y = moyenne_velo, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des vélos en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des vélos",
       color = "Condition") +
  theme_minimal()



resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(17, 18) & weekday %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday") & holiday==FALSE)
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_vehicule = mean(vehicule, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_vehicule)
    
    # Effectuer le test t
    test_w <- wilcox.test(vehicule ~ pluie, data = V2_meteo_mod)

    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
q = ggplot(resultats, aes(x = seuil, y = moyenne_vehicule, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des véhicule en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des véhicules",
       color = "Condition") +
  theme_minimal()

gridExtra::grid.arrange(p, q, ncol = 2)


# suppression des variables qui viennent d'être créées pour libérer de la mémoire
rm(resultats, p, q, seuils, V2_meteo_mod, moyenne, test_w)
```


# Même analyse en filtrant tout d'abors sur la période non scolaire (holiday=TRUE) et en semaine

## Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le matin (7h et 8h), en semaine et pendant la période non scolaire

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(7, 8) & weekday %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday") & holiday==TRUE)
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_velo = mean(bike, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_velo)
    
    # Effectuer le test t
    test_w <- wilcox.test(bike ~ pluie, data = V2_meteo_mod)
    
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
p = ggplot(resultats, aes(x = seuil, y = moyenne_velo, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des véhicules en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des véhicules",
       color = "Condition") +
  theme_minimal()


resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(7, 8) & weekday %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday") & holiday==TRUE)
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_vehicule = mean(vehicule, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_vehicule)
    
    # Effectuer le test t
    test_w <- wilcox.test(vehicule ~ pluie, data = V2_meteo_mod)

    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
q = ggplot(resultats, aes(x = seuil, y = moyenne_vehicule, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des véhicule en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des véhicules",
       color = "Condition") +
  theme_minimal()

gridExtra::grid.arrange(p, q, ncol = 2)


# suppression des variables qui viennent d'être créées pour libérer de la mémoire
rm(resultats, p, q, seuils, V2_meteo_mod, moyenne, test_w)
```

## Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le SOIR (17h et 18h), en semaine et pendant la période non scolaire


```{r, echo=FALSE}
# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > 5.1, "pluie", "non pluie")) %>% filter(hour %in% c(17, 18, 19) & weekday %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday") & holiday==TRUE)
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_velo = mean(bike, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_velo)
    
    # Effectuer le test t
    test_w <- wilcox.test(bike ~ pluie, data = V2_meteo_mod)
    
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
p = ggplot(resultats, aes(x = seuil, y = moyenne_velo, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des vélos en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des vélos",
       color = "Condition") +
  theme_minimal()


resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(17, 18, 19) & weekday %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday") & holiday==TRUE)
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(moyenne_vehicule = mean(vehicule, na.rm = TRUE)) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, moyenne_vehicule)
    
    # Effectuer le test t
    test_w <- wilcox.test(vehicule ~ pluie, data = V2_meteo_mod)

    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
ggplot(resultats, aes(x = seuil, y = moyenne_vehicule, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la moyenne des véhicule en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des véhicules",
       color = "Condition") +
  theme_minimal()

#gridExtra::grid.arrange(p, q, ncol = 2)

# suppression des variables qui viennent d'être créées pour libérer de la mémoire
rm(resultats, p, q, seuils, V2_meteo_mod, moyenne, test_w)
```

Pas de résultats car durant toute cette période il n y a pas eu de pluies observées...



# Autre axe d'analyse à partir des proportions de vélos et de véhicules (selon la situation pluvieuse ou non) en fonction du seuil de pluie

Le calcul de proportion sera fait pour chaque période (pluie et non pluie) et pour chaque seuil de pluie. Ainsi on aura par exemple pour la proportion de vélo pendant la période pluvieuse: $nbrVeloPluie/traficTotalPluie$ qui sera comparé à la proportion de véhicule pendant la période pluvieuse: $nbrVehiculePluie/traficTotalPluie$ afin de ressortir le comportement de l'un par rapport à l'autre en fonction du seuil de pluie.

# Comparaison de la proportion des vélos puis des véhicules en fonction du seuil de pluie


```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(
  seuil = numeric(),
  condition = character(),
  moyenne_vehicule = numeric(),
  p_value = numeric()
)

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie"))
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(
        total_velo = sum(bike, na.rm = TRUE),
        total_trafic = sum(vehicule + bike, na.rm = TRUE)
      ) %>%
      mutate(rapport_velo = total_velo / total_trafic) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, total_velo, rapport_velo)
    
    # Effectuer le test t
    test_w <- wilcox.test(bike ~ pluie, data = V2_meteo_mod)
    
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(data.table(resultats))

# Création du graphique
p = ggplot(resultats,
           aes(
             x = seuil,
             y = rapport_velo,
             color = condition,
             group = condition
           )) +
  geom_line() +
  geom_point() +
  labs(
    title = "Évolution de la moyenne des vélos en fonction du seuil de pluie",
    x = "Seuil de pluie (mm)",
    y = "Moyenne des vélos",
    color = "Condition"
  ) +
  theme_minimal()


# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(
  seuil = numeric(),
  condition = character(),
  moyenne_vehicule = numeric(),
  p_value = numeric()
)

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie"))
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(
        total_vehicule = sum(vehicule, na.rm = TRUE),
        total_trafic = sum(vehicule + bike, na.rm = TRUE)
      ) %>%
      mutate(rapport_vehicule = total_vehicule / total_trafic) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, total_vehicule, rapport_vehicule)
    
    # Effectuer le test t
    test_w <- wilcox.test(vehicule ~ pluie, data = V2_meteo_mod)
    
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(data.table(resultats))

# Création du graphique
q = ggplot(resultats,
           aes(
             x = seuil,
             y = rapport_vehicule,
             color = condition,
             group = condition
           )) +
  geom_line() +
  geom_point() +
  labs(
    title = "Évolution de la moyenne des véhicules en fonction du seuil de pluie",
    x = "Seuil de pluie (mm)",
    y = "Moyenne des véhicules",
    color = "Condition"
  ) +
  theme_minimal()


gridExtra::grid.arrange(p, q, ncol = 2)


# suppression des variables qui viennent d'être créées pour libérer de la mémoire
rm(resultats, p, q, seuils, V2_meteo_mod, moyenne, test_w)
```


## Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le matin (7h et 8h) et en semaine

Le 1er tableau présente les résultats pour les vélos et le 2ème pour les véhicules et en 3e position nous avons le graphique nous permettant de visualiser l'évolution de la moyenne des vélos et des véhicules en fonction du seuil de pluie.

```{r, echo=FALSE, "Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le matin (7h et 8h) et en semaine"}

# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(
  seuil = numeric(),
  condition = character(),
  rapport_velo = numeric(),
  p_value = numeric()
)

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(
    hour %in% c(7, 8) &
      weekday %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday")
  )
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(
        total_velo = sum(bike, na.rm = TRUE),
        total_trafic = sum(vehicule + bike, na.rm = TRUE)
      ) %>%
      mutate(rapport_velo = total_velo / total_trafic) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, total_velo, rapport_velo)
    
    # Effectuer le test t
    test_w <- wilcox.test(bike ~ pluie, data = V2_meteo_mod)
    
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
p = ggplot(resultats,
           aes(
             x = seuil,
             y = rapport_velo,
             color = condition,
             group = condition
           )) +
  geom_line() +
  geom_point() +
  labs(
    title = "Évolution de la proportion de vélos en fonction du seuil de pluie",
    x = "Seuil de pluie (mm)",
    y = "Moyenne des vélos",
    color = "Condition"
  ) +
  theme_minimal()


# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(
  seuil = numeric(),
  condition = character(),
  rapport_vehicule = numeric(),
  p_value = numeric()
)

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(
    hour %in% c(7, 8) &
      weekday %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday")
  )
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(
        total_vehicule = sum(vehicule, na.rm = TRUE),
        total_trafic = sum(vehicule + bike, na.rm = TRUE)
      ) %>%
      mutate(rapport_vehicule = total_vehicule / total_trafic) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, total_vehicule, rapport_vehicule)
    
    # Effectuer le test t
    test_w <- wilcox.test(vehicule ~ pluie, data = V2_meteo_mod)
    
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
q = ggplot(resultats,
           aes(
             x = seuil,
             y = rapport_vehicule,
             color = condition,
             group = condition
           )) +
  geom_line() +
  geom_point() +
  labs(
    title = "Évolution de la proportion de véhicules en fonction du seuil de pluie",
    x = "Seuil de pluie (mm)",
    y = "Moyenne des véhicules",
    color = "Condition"
  ) +
  theme_minimal()

gridExtra::grid.arrange(p, q, ncol = 2)


# suppression des variables qui viennent d'être créées pour libérer de la mémoire
rm(resultats, p, q, seuils, V2_meteo_mod, moyenne, test_w)
```


## Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le SOIR (17h et 18h) et en semaine

```{r, echo=FALSE, "Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le SOIR (17h et 18h) et en semaine"}
# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(17, 18) & weekday %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday"))
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(total_velo = sum(bike, na.rm = TRUE),
                total_trafic = sum(vehicule + bike, na.rm = TRUE)) %>%
      mutate(rapport_velo = total_velo/total_trafic) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, total_velo, rapport_velo)
    
    # Effectuer le test t
    test_w <- wilcox.test(bike ~ pluie, data = V2_meteo_mod)
    
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
p = ggplot(resultats, aes(x = seuil, y = rapport_velo, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la proportion de vélos en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des vélos",
       color = "Condition") +
  theme_minimal()


# Initialisation des seuils et du tableau pour les résultats
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(17, 18) & weekday %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday"))
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(total_vehicule = sum(vehicule, na.rm = TRUE),
                total_trafic = sum(vehicule + bike, na.rm = TRUE)) %>%
      mutate(rapport_vehicule = total_vehicule/total_trafic) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, total_vehicule, rapport_vehicule)
    
    # Effectuer le test t
    test_w <- wilcox.test(vehicule ~ pluie, data = V2_meteo_mod)
   
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
q = ggplot(resultats, aes(x = seuil, y = rapport_vehicule, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la proportion de véhicules en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des véhicules",
       color = "Condition") +
  theme_minimal()

gridExtra::grid.arrange(p, q, ncol = 2)

# suppression des variables qui viennent d'être créées pour libérer de la mémoire
rm(resultats, p, q, seuils, V2_meteo_mod, moyenne, test_w)
```


## Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le matin (7h et 8h) et en week end.


Le 1er tableau présente les résultats pour les vélos et le 2ème pour les véhicules et en 3e position nous avons le graphique nous permettant de visualiser l'évolution de la moyenne des vélos et des véhicules en fonction du seuil de pluie.


```{r, echo=FALSE, message=FALSE, "Comparaison de la moyenne des vélos puis des véhicules"}

# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(7, 8) & weekday %in% c("Saturday", "Sunday"))
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(total_velo = sum(bike, na.rm = TRUE),
                total_trafic = sum(vehicule + bike, na.rm = TRUE)) %>%
      mutate(rapport_velo = total_velo/total_trafic) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, total_velo, rapport_velo)
    
    # Effectuer le test t
    test_w <- wilcox.test(bike ~ pluie, data = V2_meteo_mod)
   
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
p = ggplot(resultats, aes(x = seuil, y = rapport_velo, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la proportion de vélos en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des vélos",
       color = "Condition") +
  theme_minimal()


# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(7, 8) & weekday %in% c("Saturday", "Sunday"))
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(total_vehicule = sum(vehicule, na.rm = TRUE),
                total_trafic = sum(vehicule + bike, na.rm = TRUE)) %>%
      mutate(rapport_vehicule = total_vehicule/total_trafic) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, total_vehicule, rapport_vehicule)
    
    # Effectuer le test t
    test_w <- wilcox.test(vehicule ~ pluie, data = V2_meteo_mod)
   
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
q = ggplot(resultats, aes(x = seuil, y = rapport_vehicule, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la proportion de véhicules en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des véhicules",
       color = "Condition") +
  theme_minimal()

gridExtra::grid.arrange(p, q, ncol = 2)


# suppression des variables qui viennent d'être créées pour libérer de la mémoire
rm(resultats, p, q, seuils, V2_meteo_mod, moyenne, test_w)
```


## Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le SOIR (17h et 18h) et le weekend

```{r, echo=FALSE, message=FALSE}
# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(17, 18) & weekday %in% c("Saturday", "Sunday"))
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(total_velo = sum(bike, na.rm = TRUE),
                total_trafic = sum(vehicule + bike, na.rm = TRUE)) %>%
      mutate(rapport_velo = total_velo/total_trafic) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, total_velo, rapport_velo)
    
    # Effectuer le test t
    test_w <- wilcox.test(bike ~ pluie, data = V2_meteo_mod)
    
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
p = ggplot(resultats, aes(x = seuil, y = rapport_velo, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la proportion de vélos en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des vélos",
       color = "Condition") +
  theme_minimal()


# Initialisation des seuils et du tableau pour les résultats
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(17, 18) & weekday %in% c("Saturday", "Sunday"))
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(total_vehicule = sum(vehicule, na.rm = TRUE),
                total_trafic = sum(vehicule + bike, na.rm = TRUE)) %>%
      mutate(rapport_vehicule = total_vehicule/total_trafic) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, total_vehicule, rapport_vehicule)
    
    # Effectuer le test t
    test_w <- wilcox.test(vehicule ~ pluie, data = V2_meteo_mod)
   
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
q = ggplot(resultats, aes(x = seuil, y = rapport_vehicule, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la proportion de véhicules en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des véhicules",
       color = "Condition") +
  theme_minimal()

gridExtra::grid.arrange(p, q, ncol = 2)

# suppression des variables qui viennent d'être créées pour libérer de la mémoire
rm(resultats, p, q, seuils, V2_meteo_mod, moyenne, test_w)
```


# Même analyse en filtrant tout d'abors sur la période scolaire (holiday=FALSE) et en semaine

## Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le matin (7h et 8h), en semaine et pendant la période scolaire

```{r, echo=FALSE, message=FALSE}
# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_velo = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(7, 8) & weekday %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday") & holiday==FALSE)
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(total_velo = sum(bike, na.rm = TRUE),
                total_trafic = sum(vehicule + bike, na.rm = TRUE)) %>%
      mutate(rapport_velo = total_velo/total_trafic) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, total_velo, rapport_velo)
    
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
p = ggplot(resultats, aes(x = seuil, y = rapport_velo, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la proportion de vélos en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des vélos",
       color = "Condition") +
  theme_minimal()

resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(7, 8) & weekday %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday") & holiday==FALSE)
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(total_vehicule = sum(vehicule, na.rm = TRUE),
                total_trafic = sum(vehicule + bike, na.rm = TRUE)) %>%
      mutate(rapport_vehicule = total_vehicule/total_trafic) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, total_vehicule, rapport_vehicule)
    
    # Effectuer le test t
    test_w <- wilcox.test(vehicule ~ pluie, data = V2_meteo_mod)
    
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
q = ggplot(resultats, aes(x = seuil, y = rapport_vehicule, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la proportion de véhicules en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des véhicules",
       color = "Condition") +
  theme_minimal()

gridExtra::grid.arrange(p, q, ncol = 2)

# suppression des variables qui viennent d'être créées pour libérer de la mémoire
rm(resultats, p, q, seuils, V2_meteo_mod, moyenne, test_w)
```


## Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le SOIR (17h et 18h), en semaine et pendant la période scolaire

```{r, echo=FALSE, message=FALSE}
# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), rapport_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(17, 18) & weekday %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday") & holiday==FALSE)
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(total_velo = sum(bike, na.rm = TRUE),
                total_trafic = sum(vehicule + bike, na.rm = TRUE)) %>%
      mutate(rapport_velo = total_velo/total_trafic) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, total_velo, rapport_velo)
    
    # Effectuer le test t
    test_w <- wilcox.test(bike ~ pluie, data = V2_meteo_mod)

    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
p = ggplot(resultats, aes(x = seuil, y = rapport_velo, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la proportion de vélos en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des vélos",
       color = "Condition") +
  theme_minimal()



resultats <- data.frame(seuil = numeric(), condition = character(), rapport_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(17, 18) & weekday %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday") & holiday==FALSE)
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(total_vehicule = sum(vehicule, na.rm = TRUE),
                total_trafic = sum(vehicule + bike, na.rm = TRUE)) %>%
      mutate(rapport_vehicule = total_vehicule/total_trafic) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, total_vehicule, rapport_vehicule)
    
    # Effectuer le test t
    test_w <- wilcox.test(vehicule ~ pluie, data = V2_meteo_mod)

    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
q = ggplot(resultats, aes(x = seuil, y = rapport_vehicule, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la proportion de véhicule en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des véhicules",
       color = "Condition") +
  theme_minimal()

gridExtra::grid.arrange(p, q, ncol = 2)

# suppression des variables qui viennent d'être créées pour libérer de la mémoire
rm(resultats, p, q, seuils, V2_meteo_mod, moyenne, test_w)
```


## Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le matin (7h et 8h), en week end et pendant la période scolaire

```{r, echo=FALSE, message=FALSE}
# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_velo = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(7, 8) & weekday %in% c("Saturday", "Sunday") & holiday==FALSE)
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(total_velo = sum(bike, na.rm = TRUE),
                total_trafic = sum(vehicule + bike, na.rm = TRUE)) %>%
      mutate(rapport_velo = total_velo/total_trafic) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, total_velo, rapport_velo)
    
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
p = ggplot(resultats, aes(x = seuil, y = rapport_velo, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la proportion de vélos en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des vélos",
       color = "Condition") +
  theme_minimal()

resultats <- data.frame(seuil = numeric(), condition = character(), moyenne_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(7, 8) & weekday %in% c("Saturday", "Sunday") & holiday==FALSE)
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(total_vehicule = sum(vehicule, na.rm = TRUE),
                total_trafic = sum(vehicule + bike, na.rm = TRUE)) %>%
      mutate(rapport_vehicule = total_vehicule/total_trafic) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, total_vehicule, rapport_vehicule)
    
    # Effectuer le test t
    test_w <- wilcox.test(vehicule ~ pluie, data = V2_meteo_mod)
    
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
q = ggplot(resultats, aes(x = seuil, y = rapport_vehicule, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la proportion de véhicules en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des véhicules",
       color = "Condition") +
  theme_minimal()

gridExtra::grid.arrange(p, q, ncol = 2)



# suppression des variables qui viennent d'être créées pour libérer de la mémoire
rm(resultats, p, q, seuils, V2_meteo_mod, moyenne, test_w)
```




## Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le SOIR (17h et 18h), en week end et pendant la période scolaire

```{r, echo=FALSE, message=FALSE}
# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), rapport_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(17, 18) & weekday %in% c("Saturday", "Sunday") & holiday==FALSE)
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(total_velo = sum(bike, na.rm = TRUE),
                total_trafic = sum(vehicule + bike, na.rm = TRUE)) %>%
      mutate(rapport_velo = total_velo/total_trafic) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, total_velo, rapport_velo)
    
    # Effectuer le test t
    test_w <- wilcox.test(bike ~ pluie, data = V2_meteo_mod)

    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
p = ggplot(resultats, aes(x = seuil, y = rapport_velo, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la proportion de vélos en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des vélos",
       color = "Condition") +
  theme_minimal()



resultats <- data.frame(seuil = numeric(), condition = character(), rapport_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(17, 18) & weekday %in% c("Saturday", "Sunday") & holiday==FALSE)
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(total_vehicule = sum(vehicule, na.rm = TRUE),
                total_trafic = sum(vehicule + bike, na.rm = TRUE)) %>%
      mutate(rapport_vehicule = total_vehicule/total_trafic) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, total_vehicule, rapport_vehicule)
    
    # Effectuer le test t
    test_w <- wilcox.test(vehicule ~ pluie, data = V2_meteo_mod)

    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
q = ggplot(resultats, aes(x = seuil, y = rapport_vehicule, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la proportion de véhicule en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des véhicules",
       color = "Condition") +
  theme_minimal()

gridExtra::grid.arrange(p, q, ncol = 2)


# suppression des variables qui viennent d'être créées pour libérer de la mémoire
rm(resultats, p, q, seuils, V2_meteo_mod, moyenne, test_w)
```

# Même analyse en filtrant tout d'abors sur la période non scolaire (holiday=TRUE) et en semaine

## Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le matin (7h et 8h), en week end et pendant la période non scolaire

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), rapport_velo = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(7, 8) & weekday %in% c("Saturday", "Sunday") & holiday==TRUE)
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(total_velo = sum(bike, na.rm = TRUE),
                total_trafic = sum(vehicule + bike, na.rm = TRUE)) %>%
      mutate(rapport_velo = total_velo/total_trafic) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, total_velo, rapport_velo)
    
    # Effectuer le test t
    test_w <- wilcox.test(bike ~ pluie, data = V2_meteo_mod)
    
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
p = ggplot(resultats, aes(x = seuil, y = rapport_velo, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la proportion de véhicules en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des véhicules",
       color = "Condition") +
  theme_minimal()


resultats <- data.frame(seuil = numeric(), condition = character(), rapport_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(7, 8) & weekday %in% c("Saturday", "Sunday") & holiday==TRUE)
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(total_vehicule = sum(vehicule, na.rm = TRUE),
                total_trafic = sum(vehicule + bike, na.rm = TRUE)) %>%
      mutate(rapport_vehicule = total_vehicule/total_trafic) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, total_vehicule, rapport_vehicule)
    
    # Effectuer le test t
    test_w <- wilcox.test(vehicule ~ pluie, data = V2_meteo_mod)

    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
q = ggplot(resultats, aes(x = seuil, y = rapport_vehicule, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la proportion de véhicule en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des véhicules",
       color = "Condition") +
  theme_minimal()

gridExtra::grid.arrange(p, q, ncol = 2)


# suppression des variables qui viennent d'être créées pour libérer de la mémoire
rm(resultats, p, q, seuils, V2_meteo_mod, moyenne, test_w)
```




## Comparaison de la moyenne des vélos puis des véhicules en fonction du seuil de pluie pendant les heures d'affluence le SOIR (17h et 18h), en week end et pendant la période non scolaire


```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Initialisation des seuils et du tableau pour les résultats
seuils <- seq(0.1, 6, by = 0.5)
resultats <- data.frame(seuil = numeric(), condition = character(), rapport_velo = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > 5.1, "pluie", "non pluie")) %>% filter(hour %in% c(17, 18, 19) & weekday %in% c("Saturday", "Sunday") & holiday==TRUE)
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(total_velo = sum(bike, na.rm = TRUE),
                total_trafic = sum(vehicule + bike, na.rm = TRUE)) %>%
      mutate(rapport_velo = total_velo/total_trafic) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, total_velo, rapport_velo)
    
    # Effectuer le test t
    test_w <- wilcox.test(bike ~ pluie, data = V2_meteo_mod)
    
    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
p = ggplot(resultats, aes(x = seuil, y = rapport_velo, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la proportion de vélos en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des vélos",
       color = "Condition") +
  theme_minimal()


resultats <- data.frame(seuil = numeric(), condition = character(), rapport_vehicule = numeric(), p_value = numeric())

# Calcul des moyennes et des p-values pour chaque seuil
for (i in seuils) {
  V2_meteo_mod <- V2_meteo %>% mutate(pluie = ifelse(RR1 > i, "pluie", "non pluie")) %>% filter(hour %in% c(17, 18, 19) & weekday %in% c("Saturday", "Sunday") & holiday==TRUE)
  
  # Vérifier que le facteur de regroupement a exactement 2 niveaux
  if (length(unique(V2_meteo_mod$pluie)) == 2) {
    moyenne <- V2_meteo_mod %>%
      group_by(pluie) %>%
      summarise(total_vehicule = sum(vehicule, na.rm = TRUE),
                total_trafic = sum(vehicule + bike, na.rm = TRUE)) %>%
      mutate(rapport_vehicule = total_vehicule/total_trafic) %>%
      mutate(seuil = i, condition = pluie) %>%
      select(seuil, condition, total_vehicule, rapport_vehicule)
    
    # Effectuer le test t
    test_w <- wilcox.test(vehicule ~ pluie, data = V2_meteo_mod)

    # Ajouter les résultats du test t
    moyenne <- moyenne %>%
      mutate(p_value = test_w$p.value)
    
    resultats <- rbind(resultats, moyenne)
  }
}

# Afficher les résultats
print(resultats)

# Création du graphique
q = ggplot(resultats, aes(x = seuil, y = rapport_vehicule, color = condition, group = condition)) +
  geom_line() +
  geom_point() +
  labs(title = "Évolution de la proportion de véhicule en fonction du seuil de pluie",
       x = "Seuil de pluie (mm)",
       y = "Moyenne des véhicules",
       color = "Condition") +
  theme_minimal()

gridExtra::grid.arrange(p, q, ncol = 2)

# suppression des variables qui viennent d'être créées pour libérer de la mémoire
rm(resultats, p, q, seuils, V2_meteo_mod, moyenne, test_w)
```

Pas de résultats car durant toute cette période il n y a pas eu de pluies observées...



Pour une analyse plus fine et plus représentative de l'influence du climat sur le trafic, on pourrait suivre une approche différente qui prend en compte les variations journalières et les conditions météorologiques spécifiques.

# Analyse de la variation du trafic en fonction des conditions météorologiques et des heures de la journée

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Agréger les données par jour

daily_data <- V2_meteo %>%
  group_by(day) %>%
  summarise(total_rr1 = sum(RR1, na.rm = TRUE),
            total_bike = sum(bike, na.rm = TRUE),
            total_vehicule = sum(vehicule, na.rm = TRUE),
            total_trafic = sum(vehicule + bike, na.rm = TRUE))

# Classifier les jours en fonction de la quantité totale de pluie
daily_data <- daily_data %>%
  mutate(category = case_when(
    total_rr1 == 0 ~ "Journée sans pluie",
    total_rr1 > 0 & total_rr1 <= 5 ~ "Journées de faible pluie",
    total_rr1 > 5 & total_rr1 <= 20 ~ "Journées de pluie modérée",
    total_rr1 > 20 ~ "Journées de pluie plus forte"
  ))

# Calculer les proportions moyennes pour chaque catégorie de jour
proportions <- daily_data %>%
  group_by(category) %>%
  summarise(mean_bike_prop = mean(total_bike / total_trafic, na.rm = TRUE),
            mean_vehicule_prop = mean(total_vehicule / total_trafic, na.rm = TRUE))

# Visualisation des proportions moyennes
p = ggplot(proportions, aes(x = category)) +
  geom_point(aes(y = mean_bike_prop), size = 3, color = "green") +
  geom_line(aes(y = mean_bike_prop, group = 1), color = "purple") +
  labs(title = "Average Proportions of bike by Day Category",
       x = "Day Category",
       y = "Proportion") + theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))


q = ggplot(proportions, aes(x = category)) +
geom_point(aes(y = mean_vehicule_prop), size = 3, color = "red") +
  geom_line(aes(y = mean_vehicule_prop, group = 1)) +
  labs(title = "Average Proportions of vehicule by Day Category",
       x = "Day Category",
       y = "Proportion") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

gridExtra::grid.arrange(p, q, ncol = 2)

# suppression des variables qui viennent d'être créées pour libérer de la mémoire
rm(daily_data, proportions, p, q)

```


**Proportion de vélos :**

  + Journées sans pluie et faible pluie : La proportion de vélos est relativement élevée.
  + Journées de pluie modérée : La proportion de vélos diminue de manière significative.
  + Journées de pluie plus forte : La proportion de vélos augmente légèrement par rapport aux journées de pluie modérée mais reste inférieure aux journées sans pluie.
  
**Proportion de véhicules :**

  + Journées sans pluie : La proportion de véhicules est la plus basse.
  + Journées de faible pluie : La proportion de véhicules augmente.
  + Journées de pluie modérée et plus forte : La proportion de véhicules est plus élevée par rapport aux journées sans pluie, mais montre une légère diminution pour les journées de pluie plus forte.

Ces observations suggèrent que la météo a un impact significatif sur les proportions de vélos et de véhicules. Les cyclistes semblent moins enclins à utiliser leurs vélos par temps de pluie modérée à forte, tandis que la proportion de véhicules augmente dans ces conditions.



# Méthodologie alternative

Pour une analyse plus pertinente de l'influence de la météo sur le trafic, il est possible de combiner différentes approches, notamment l'analyse des proportions et des moyennes, en incluant des analyses temporelles et des tests statistiques pour confirmer les observations.


```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Filtrer les jours où il a plu
days_with_rain <- V2_meteo %>% mutate(pluie = ifelse(RR1 > 1.5, "pluie", "non pluie")) %>% 
  group_by(day) %>%
  filter(any(RR1 > 1.5)) %>%
  ungroup()

# Calculer les moyennes horaires pour chaque condition par jour
hourly_averages <- days_with_rain %>%
  group_by(day, pluie) %>%
  summarise(mean_bike = mean(bike, na.rm = TRUE),
            mean_vehicule = mean(vehicule, na.rm = TRUE),
            total_trafic = mean(vehicule + bike, na.rm = TRUE), .groups="keep") %>%
  ungroup()

# Calculer les proportions horaires pour chaque condition par jour
hourly_proportions <- hourly_averages %>%
  mutate(proportion_bike = mean_bike / total_trafic,
         proportion_vehicule = mean_vehicule / total_trafic)

# Visualisation des proportions moyennes
col = ifelse(days_with_rain$weekday %in% c("Saturday", "Sunday"), "green", "brown")

p = ggplot(hourly_proportions, aes(x = day, y = proportion_bike, color = pluie, group = 1)) +
  geom_point() +
  geom_line() +
  labs(title = "Proportion de vélos par heure et par condition",
       x = "Heure",
       y = "Proportion de vélos") +
  scale_color_manual(name = "Condition", values = c("non pluie" = "red", "pluie" = "blue")) +
  theme_minimal()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1, colour = col))

q = ggplot(hourly_proportions, aes(x = day, y = proportion_vehicule, color = pluie, group = 1)) +
  geom_point() +
  geom_line() +
  labs(title = "Proportion de véhicules par heure et par condition",
       x = "Heure",
       y = "Proportion de véhicules") +
  scale_color_manual(name = "Condition", values = c("non pluie" = "red", "pluie" = "blue")) +
  theme_minimal()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1, colour = col))

gridExtra::grid.arrange(p, q, ncol = 2)


# suppression des variables qui viennent d'être créées pour libérer de la mémoire
rm(days_with_rain, hourly_averages, hourly_proportions, p, q, col)
```




# Autres analyses possibles

```{r}
# Filtrer les jours où il a plu
days_with_rain <- V2_meteo%>%
  group_by(day) %>%
  filter(any(RR1 > 2)) %>%
  ungroup()

# Calculer les proportions journalières pour chaque condition
daily_proportions <- days_with_rain %>%
  group_by(day) %>%
  summarise(total_bike = sum(bike, na.rm = TRUE),
            total_vehicule = sum(vehicule, na.rm = TRUE),
            total_trafic = sum(vehicule + bike),
            pluie = max(RR1, na.rm = TRUE)) %>%
  mutate(proportion_bike = total_bike / total_trafic,
         proportion_vehicule = total_vehicule / total_trafic,
         condition = case_when(
           pluie == 0 ~ "Journées sans pluie",
           pluie <= 2 ~ "Journées de faible pluie",
           pluie <= 4 ~ "Journées de pluie modérée",
           TRUE ~ "Journées de pluie plus forte"
         )) %>%
  ungroup()

# Visualisation des proportions journalières
p = ggplot(daily_proportions, aes(x = day, y = proportion_bike, color = condition, group = 1)) +
  geom_point() +
  geom_line() +
  labs(title = "Proportion de vélos par jour et par condition",
       x = "Jour",
       y = "Proportion de vélos") +
  scale_color_manual(name = "Condition", values = c("Journées sans pluie" = "red", "Journées de faible pluie" = "green", "Journées de pluie modérée" = "blue", "Journées de pluie plus forte" = "purple")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  facet_wrap(~condition, scales = "free_x")

q = ggplot(daily_proportions, aes(x = day, y = proportion_vehicule, color = condition, group=1)) +
  geom_point() +
  geom_line() +
  labs(title = "Proportion de véhicules par jour et par condition",
       x = "Jour",
       y = "Proportion de véhicules") +
  scale_color_manual(name = "Condition", values = c("Journées sans pluie" = "red", "Journées de faible pluie" = "green", "Journées de pluie modérée" = "blue", "Journées de pluie plus forte" = "purple")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  facet_wrap(~condition, scales = "free_x")

gridExtra::grid.arrange(p, q, nrow = 2)

# suppression des variables qui viennent d'être créées pour libérer de la mémoire
rm(days_with_rain, daily_proportions, p,q)

```


