---
title: "Analyse de Corrélation"
author: "Kevin"
date: system date()
output:
  rmdformats::downcute:
    logo: logo.jpg
    favicon: logo.jpg
    downcute_theme: chaos
    highlight: tango
    number_sections: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```




```{r, message=FALSE, include=FALSE,warning=FALSE, "Import autre fichiers"}
source("fonction_meteo.R")
source("Import_Data.R")
source("fonction_filtre_data.R")

```



```{r, message=FALSE, include=FALSE ,echo=FALSE, "Import packages"}
library(telraamStats)
library(ggplot2)
library(tidyverse)
library(patchwork)
library(prophet)
library(corrplot)

#devtools::install_github("https://github.com/KetsiaGuichard/telraamStats",
 #                        dependencies = TRUE,
  #                       build_vignettes = TRUE)
```




```{r, include=FALSE, "Ajout du type de NA"}
# Ajout de la colonne du type de données manquantes

liste_data_capteurs = list(data_01, data_02, data_04, data_05,data_06, data_07, data_08,data_10, data_11, data_13, data_14, data_15, data_16, data_18)


for(i in 1:length(liste_data_capteurs)){
  liste_data_capteurs[[i]] = NA_Type(liste_data_capteurs[[i]])
}

visu_na(new_data(meteo, liste_data_capteurs[[1]]))
visu_na(meteo)
visu_na(liste_data_capteurs[[1]] %>% filter(type==2))
```





```{r message=FALSE, warning=FALSE, include=FALSE, "Corrélation cahque capteurs"}
## Analyse de corrélation des variables météo avec chaque capteur indépendemment.

#On fait le choix de ne rien enlever comme données pour cette première analyse afin de voir l'impact après #suppression de certaines données (les heures de nuit). 



#Création de liste de données capteur + météo

liste_data_capteurs_meteo <- list()

for(i in 1:length(liste_data_capteurs)){
  liste_data_capteurs_meteo[[i]] = new_data(meteo, liste_data_capteurs[[i]])
}


# Matrice de corrélation pour chaque variable

for(i in 1:length(liste_data_capteurs_meteo)){
 corrélation_uptime(liste_data_capteurs_meteo[[i]], liste_var_selected = c("T", "U", "VV", "RR1", "GLO", "pedestrian", "vehicule"))
}

```



# Analyse de corrélation sur les variables météo et l'ensemble des capteurs

+ avec filtre des données manquantes de type 2 (faisant varier le seuil definissant le type 2 de 25 à 50 pas de 5) mais sans suppression de données de la nuit

L'objectif étant de constater la nuances du résultat des corrélations avant et après suppression

```{r, echo=FALSE}
for(i in seq(25, 50, 5)){
  corrélation_uptime(new_data(meteo, (NA_Type(sensors, threshold = i))) %>% filter(type==2), liste_var_selected = c("T", "U", "VV", "GLO", "pedestrian", "vehicule"))
}
```

On remarque que plus on augmente le seuil plus les corrélation diminue mais faiblement

------------------

+ avec un filtre sur les valeurs manquantes de type 2 (faisant varier le seuil nous permettant de définir les valeurs manquantes de type 2 de 25 à 50 avec un pas de 5) et suppression des heures de nuit


```{r, message=FALSE, warning=FALSE, echo=FALSE}

for(i in seq(25, 50, 5)){
  corrélation_uptime(new_data(meteo, stop_sensor(NA_Type(sensors, threshold = i), remove_data = TRUE, uptime_choice = 0.5)) %>% filter(type==2), liste_var_selected = c("T", "U", "VV", "GLO", "pedestrian", "vehicule"))
}

```

La remarque reste la même que précédemment: plus on augmente le seuil plus les corrélation diminue mais faiblement



# Analyse de corrélation de l'ensemble des capteurs sans filtre de données manquantes de type 2 mais avec suppression des heures de nuit


```{r, message=FALSE, warning=FALSE, echo=FALSE}
corrélation_uptime(new_data(meteo, stop_sensor(NA_Type(sensors))), liste_var_selected = c("T", "U", "VV", "RR1", "GLO", "pedestrian", "vehicule"))
```


On remarque que les corrélation sont plus faibles que les précédentes (avec un seuil de 50%) ce qui confirme le fait que les données manquantes de type 2 sont plus corrélées avec les variables météo



# Analyse de corrélation de l'ensemble des capteurs avec un filtre sur les valeurs manquantes de type 2 sans suppression des heures de nuit.


```{r, echo=FALSE}
corrélation_uptime(new_data(meteo, NA_Type(sensors)) %>% filter(type==2), liste_var_selected = c("T", "U", "VV", "RR1", "GLO", "pedestrian", "vehicule"))

```


Malgré le fait que l'on conserve les heures de nuit, les corrélations sont toutes autant importantes.

------------------

# Corrélation à partir d'une ACP sur les données nettoyées sans filtre de NA de type 2

```{r, message=FALSE, warning=FALSE, echo=FALSE}
ACP1 = FactoMineR::PCA(new_data(meteo, stop_sensor(NA_Type(sensors))) %>% select(uptime, U, T, GLO, VV, RR1), scale.unit = TRUE, graph = FALSE)

# plot ACP des variables
FactoMineR::plot.PCA(ACP1, axes=c(1,2), choix="var")
```

---------------

# Corrélation à partir d'une ACP après nettoyage et filtre

```{r, message=FALSE, warning=FALSE, echo=FALSE}
ACP2 = FactoMineR::PCA(new_data(meteo, stop_sensor(NA_Type(sensors))) %>% filter(type==2) %>% select(uptime, U, T, GLO, VV, RR1), scale.unit = TRUE, graph = FALSE)

# plot ACP des variables
FactoMineR::plot.PCA(ACP2, axes=c(1,2), choix="var")
```




# Nettoyage de données

```{r}
# Récupération des données nettoyées avec les paramètres par defaut de Clean_NA_segments
sensors_cleaned = Clean_NA_segments(sensors)

# Récupération des données nettoyées et ajout des NA aux vehicules
sensors_cleaned_na = sensors_cleaned %>% mutate(vehicule = ifelse(uptime < 0.5, NA, car+heavy), operation = ifelse(uptime_quality, "original","imputed"))
```



# Imputation par EMA (Exponential Moving Average)

```{r}
# Test sur le capteur 11 (Rue de Prieure: V2)

# Récupérons les données excepté en 2024 (jeu d'entrainement)
train_data11 = sensors_cleaned_na %>% filter(year(date) < 2024 & segment_name == "Burel-01")

# Récupérons les données de janvier 2024 (jeu de test)
test_data11 = sensors_cleaned_na %>% filter(year(date) == 2024 & month(date) == 1 & segment_name == "Burel-01")

# Imputation par EMA sur le jeu de données d'entrainement

# Imputation des valeurs manquantes par interpolation cubique (spline)
train_data11$vehicule_Imputed = zoo::na.spline((train_data11$vehicule), na.rm = FALSE)



# Combler les valeurs manquantes en début et fin de série // ceci ce fait dans le cas où des données manquates se trouves en début ou fin de série
#train_data11$vehicule <- zoo::na.fill(train_data11$vehicule, "extend")

# Impuation par EMA
ema = TTR::EMA(train_data11$vehicule_Imputed, n=3)
ema = data.frame(date = train_data11$date, predic_ema = ema,  predic_spline= train_data11$vehicule_Imputed, type = train_data11$operation)


ema

# Remplacons les valeurs de type "original" de la colonne "predic_spline" dans la zone correspondante de "predic_ema"
ema$predic_ema = ifelse(ema$type == "original", ema$predic_spline, ema$predic_ema)

ggplot() +
  geom_point(data = ema, aes(x = date, y = predic_ema, color = type)) +
  geom_point(data= ema %>% filter(type=="imputed"), aes(x = date, y = predic_spline), color="green") +
  labs(title = "EMA with Imputed Values",
       x = "Date",
       y = "Value",
       color = "Data Type")

```


```{r}
# data frame avec toutes les données de 2024 de RuePrieure-11
Train_data = na.omit(train_data11)

# créons une nouvelle colonne (test) en intoduisant 20% de NA
Train_data$test = Train_data$vehicule
Train_data$test[sample(1:nrow(Train_data), nrow(Train_data)*0.2)] = NA
Train_data = Train_data %>% mutate(operation = ifelse(is.na(test), "imputed","original"))

# Imputation par EMA sur le jeu de données d'entrainement

# Imputation des valeurs manquantes par interpolation cubique (spline)
Train_data$vehicule_Imputed = zoo::na.spline((Train_data$test), na.rm = FALSE)



# Combler les valeurs manquantes en début et fin de série // ceci ce fait dans le cas où des données manquates se trouves en début ou fin de série
#train_data11$vehicule <- zoo::na.fill(train_data11$vehicule, "extend")

# Impuation par EMA
ema_test = TTR::EMA(Train_data$vehicule_Imputed, n=3)
ema_test = data.frame(date = Train_data$date, predic_ema = ema_test,  predic_spline= Train_data$vehicule_Imputed, type = Train_data$operation, original = Train_data$vehicule)




# Remplacons les valeurs de type "original" de la colonne "predic_spline" dans la zone correspondante de "predic_ema"
ema_test$predic_ema = ifelse(ema_test$type == "original", ema_test$predic_spline, ema_test$predic_ema)

ema_test %>% filter(type=="imputed")
```

```{r}
plot(ema_test$original, type = 'l', col = 'blue', ylim = range(c(ema_test$vehicule, ema_test$predic_ema)), main = "Real vs Predicted (EMA)", xlab = "Time", ylab = "Values")
lines(ema_test$predic_ema, col = 'red')
legend("topright", legend = c("Real", "Predicted"), col = c("blue", "red"), lty = 1)

```

```{r}
plot(ema_test$original, col = "blue",type="l", ylim = range(c(ema_test$vehicule, ema_test$predic_spline)), main = "Real vs Predicted (Spline interpolation)", xlab = "Time", ylab = "Values")
lines(ema_test$predic_spline, col = "red")
legend("topright", legend = c("Real", "Predicted"), col = c("blue", "red"), lty = 1)
```



```{r}
plot(ema_test$original, col = as.factor(ema_test$type), ylim = range(c(ema_test$vehicule, ema_test$predic_spline)), main = "Real vs Predicted (Spline interpolation)", xlab = "Time", ylab = "Values")
lines(ema_test$predic_spline, col = as.factor(ema_test$type))
#legend("topright", legend = c("Real", "Predicted"), col = c("blue", "red"), lty = 1)
```






# Fonction de visu de prédiction EMA et spline sur des données avant 2024

```{r}

# En vert c'est la prédiction par interpolation de spline

visu_predict = function(nom_capteur){
  
# Récupérons les données excepté en 2024 (jeu d'entrainement)
train_data = sensors_cleaned_na %>% filter(year(date) < 2024 & segment_name == nom_capteur)

# Imputation par EMA sur le jeu de données d'entrainement

# Imputation des valeurs manquantes par interpolation cubique (spline)
train_data$vehicule_Imputed = zoo::na.spline((train_data$vehicule), na.rm = FALSE)



# Combler les valeurs manquantes en début et fin de série // ceci ce fait dans le cas où des données manquates se trouves en début ou fin de série
#train_data11$vehicule <- zoo::na.fill(train_data11$vehicule, "extend")

# Impuation par EMA
ema = TTR::EMA(train_data$vehicule_Imputed, n=3)
ema = data.frame(date = train_data$date, predic_ema = ema,  predic_spline= train_data$vehicule_Imputed, type = train_data$operation)


p <- ggplot() +
  geom_point(data = ema, aes(x = date, y = predic_ema, color = type)) +
  geom_point(data= ema %>% filter(type=="imputed"), aes(x = date, y = predic_spline), color="green") +
  labs(title = "EMA with Imputed Values",
       x = "Date",
       y = "Value",
       color = "Data Type")
return(p)
}

visu_predict("BoulevardLiberté-18")
```
